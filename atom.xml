<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gillben Blog</title>
  
  <subtitle>永远走在成长的路上，不为失败找理由，只为成功找方法。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-20T01:16:26.674Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gillben</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>View加载优化之懒汉模式-ViewStub</title>
    <link href="http://yoursite.com/2018/05/20/View%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F-ViewStub/"/>
    <id>http://yoursite.com/2018/05/20/View加载优化之懒汉模式-ViewStub/</id>
    <published>2018-05-20T00:54:45.603Z</published>
    <updated>2018-05-20T01:16:26.674Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>谈到布局优化，通常都会想到标签include和merge。简单先说下这两个标签的好处：include可以减少布局文件内容，比如，在我们需要在多个布局中都添加标题栏时，可以创建一个单独的xml文件，添加标题内容到该xml中，然后在需要用到的目标布局里面用include标签添加已创建好的标题栏；merge可以减少多余的包含控件。两者一起使用，可以减少布局的层级结构，从而减少绘制的工作量。注意：include标签只支持android:layout_with和android:layout_height属性，其它属性是不支持的。O了~开始这章的重点，</p><p>很多时候，在初始化程序时都是一次性把布局加载进来，使得绘制工作量变多，导致程序初始化性能降低。比如：网络请求错误时的布局、一些评论显示的布局（未有评论前）等等，这些布局我们并不经常用到，能不能按需加载？可以，那就是ViewStub。</p></blockquote><h2 id="为什么用ViewStub能提升程序初始化性能"><a href="#为什么用ViewStub能提升程序初始化性能" class="headerlink" title="为什么用ViewStub能提升程序初始化性能"></a>为什么用ViewStub能提升程序初始化性能</h2><p>ViewSub继承于View，本身是一个视图。但其有一个特点，就是轻量级的，宽和高都为0，并且它不参与绘制和任何的布局，为什么这么说，一起看下ViewStub源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;</span><br><span class="line">        super(context);</span><br><span class="line"></span><br><span class="line">        final TypedArray a = context.obtainStyledAttributes(attrs,</span><br><span class="line">                R.styleable.ViewStub, defStyleAttr, defStyleRes);</span><br><span class="line">        mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID);</span><br><span class="line">        mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0);</span><br><span class="line">        mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID);</span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">        setVisibility(GONE);  //在初始构造方法中就已经设置了GONE</span><br><span class="line">        setWillNotDraw(true);</span><br><span class="line">    &#125;</span><br><span class="line">... ...//省略部分代码</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        setMeasuredDimension(0, 0); //测量中设置宽和高为0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw(Canvas canvas) &#123;</span><br><span class="line">    //无任何绘制</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据上面的代码，我们可以知道，声明一个ViewStub时，只是起到了一个占位的作用，并没有实际的绘制和布局。</p></blockquote><p><strong>2、怎么去使用ViewStub，做到按需加载，一起看下下面一段简单描述。</strong></p><p>首先，主布局声明一个ViewStub：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;com.rickybin.viewstubtest.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;ViewStub</span><br><span class="line">       android:id=&quot;@+id/textStub&quot;</span><br><span class="line">       android:inflatedId=&quot;@+id/text_inflate_id&quot; //设置目标布局ID</span><br><span class="line">       android:layout=&quot;@layout/text_layout&quot;   //获取目标布局</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p>text_layout的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:id=&quot;@+id/textId&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;ViewStub的目标TextView&quot; /&gt;</span><br></pre></td></tr></table></figure><p>activity的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private ViewStub textStub;</span><br><span class="line">    private TextView mTextView;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        textStub = (ViewStub) findViewById(R.id.textStub);</span><br><span class="line">        if (mTextView != null)&#123;</span><br><span class="line">            mTextView = (TextView) textStub.inflate(); //加载相应的TextView</span><br><span class="line">        &#125;</span><br><span class="line">        mTextView.setText(&quot;获取textview&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在activity代码initView()中判断mTextView是否为null，调用inflate()加载，这时就会把<strong>“@layout/text_layout”</strong>实例化出来。ViewStub还有一种方法加载布局，就是用setVisibility去加载，其实这个方法中最终还是调用了inflate()加载布局。再看看ViewStub源码中setVisibility的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void setVisibility(int visibility) &#123;</span><br><span class="line">    if (mInflatedViewRef != null) &#123;  //是否已加载目标布局</span><br><span class="line">        View view = mInflatedViewRef.get();</span><br><span class="line">        if (view != null) &#123;</span><br><span class="line">            view.setVisibility(visibility);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;setVisibility called on un-referenced view&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;   //加载目标布局</span><br><span class="line">        super.setVisibility(visibility);//先由父类setVisibility再inflate</span><br><span class="line">        if (visibility == VISIBLE || visibility == INVISIBLE) &#123;</span><br><span class="line">            inflate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然都是用inflate()加载，那我们一起看看在inflate里具体做了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public View inflate() &#123;</span><br><span class="line">        final ViewParent viewParent = getParent(); //获取ViewStub所在的父视图</span><br><span class="line"></span><br><span class="line">        if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) &#123;</span><br><span class="line">            if (mLayoutResource != 0) &#123;</span><br><span class="line">                final ViewGroup parent = (ViewGroup) viewParent;</span><br><span class="line">                final View view = inflateViewNoAdd(parent);</span><br><span class="line">                replaceSelfWithView(view, parent);  //替换ViewStub自身</span><br><span class="line"></span><br><span class="line">//把View赋值给mInflatedViewRef</span><br><span class="line">                mInflatedViewRef = new WeakReference&lt;&gt;(view);</span><br><span class="line">                if (mInflateListener != null) &#123;</span><br><span class="line">                    mInflateListener.onInflate(this, view);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return view;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//获取LayoutInflater指定的布局，赋值给变量View</span><br><span class="line">private View inflateViewNoAdd(ViewGroup parent) &#123;</span><br><span class="line">        final LayoutInflater factory;</span><br><span class="line">        if (mInflater != null) &#123;</span><br><span class="line">            factory = mInflater;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            factory = LayoutInflater.from(mContext);</span><br><span class="line">        &#125;</span><br><span class="line">        final View view = factory.inflate(mLayoutResource, parent, false);</span><br><span class="line"></span><br><span class="line">        if (mInflatedId != NO_ID) &#123;</span><br><span class="line">            view.setId(mInflatedId);</span><br><span class="line">        &#125;</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>replaceSelfWithView()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void replaceSelfWithView(View view, ViewGroup parent) &#123;</span><br><span class="line">        final int index = parent.indexOfChild(this);</span><br><span class="line">//移除父布局中的ViewStub</span><br><span class="line">parent.removeViewInLayout(this); </span><br><span class="line"></span><br><span class="line">//这里是用ViewStub的android:with和android:height设置目标布局</span><br><span class="line">        final ViewGroup.LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">        //添加目标布局到父布局中</span><br><span class="line">        if (layoutParams != null) &#123;</span><br><span class="line">            parent.addView(view, index, layoutParams);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parent.addView(view, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面我们可以分析得到结果，ViewStub去加载目标布局时，其实是先把LayoutInflater指定的layout实例化后赋值给变量View，然后ViewStub自身会从父视图中移除，再把变量View添加进父视图中。也就是说ViewStub只能inflate一次，之后ViewStub对象就会置空，不再是整个布局结构中的一部分了。要注意一点，如果ViewStub设置了inflatedId，将会赋值给变量View的id。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;谈到布局优化，通常都会想到标签include和merge。简单先说下这两个标签的好处：include可以减少布局文件内容，比如，在我们需要在多个布局中都添加标题栏时，可以创建一个单独的xml文件，添加标题内容到该xml中，然后在需要用到的目标布局里
      
    
    </summary>
    
      <category term="View系列" scheme="http://yoursite.com/categories/View%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="View" scheme="http://yoursite.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>View的事件分发</title>
    <link href="http://yoursite.com/2018/05/20/Android-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>http://yoursite.com/2018/05/20/Android-View的事件分发/</id>
    <published>2018-05-20T00:28:16.000Z</published>
    <updated>2018-05-20T01:11:59.883Z</updated>
    
    <content type="html"><![CDATA[<p>View的事件分发所针对的是MotionEvent事件，在Touch过程中会产生大量的MotionEvent，记录了与Touch相关的事件。一次ACTION_DOWN、中间可能多次ACTION_MOVE、一次ACTION_UP，这便是一次完整的MotionEvent事件。在我们点击屏幕的那一刻，会先经过硬件的一系列处理，然后在当前应用的主(UI)线程中接收到来自底层传输过来的input事件，将事件交付于ViewRootImpl的enqueueInputEvent()方法，通过ViewRootImpl的内部类InputStage转换处理，最终交给View的dispatchTouchEvent()方法，事件分发的开始。<br>一个应用程序的根视图(顶级View)是DecorView，也就是说，View的事件分发实际是由DecorView中的dispatchTouchEvent()方法开始的。</p><p>在处理View的事件分发时，View和ViewGroup(继承自View)稍有差异。</p><blockquote><ul><li>View的相关处理方法：<br>dispatchTouchEvent()、onTouchEvent()</li><li>ViewGroup的相关处理方法：<br>dispatchTouchEvent()、onInterceptTouchEvent()、onTouchEvent()</li></ul></blockquote><h3 id="1、DecorView-dispatchTouchEvent"><a href="#1、DecorView-dispatchTouchEvent" class="headerlink" title="1、DecorView # dispatchTouchEvent()"></a>1、DecorView # dispatchTouchEvent()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        final Window.Callback cb = mWindow.getCallback();</span><br><span class="line">        return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0</span><br><span class="line">                ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，mWindow是一个PhoneWindow类型的变量，在Activity的attach()方法中对mWindow进行赋值【<a href="https://www.jianshu.com/p/15605e70e170" target="_blank" rel="noopener">可以参考这篇文章 — Activity的启动过程</a>】。且Activity实现了Window.Callback接口<strong>（实现Window.Callback的不只有Activity，比如Dialog，这里以Activity为例）</strong>，也就是说：cb.dispatchTouchEvent()回调的是Activity中的dispatchTouchEvent()，执行这一步首先要满足前提条cb是否存在，PhoneWindow没有销毁，mFeatureId &lt; 0表示DecorView存在。否则会执行ViewGroup的dispatchTouchEvent()方法（DecorView继承FrameLayout）。</p><h3 id="2、Activity-dispatchTouchEvent"><a href="#2、Activity-dispatchTouchEvent" class="headerlink" title="2、Activity # dispatchTouchEvent()"></a>2、Activity # dispatchTouchEvent()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            //内部是一个空实现，用于点击时与用户交互</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        //getWindow()返回PhoneWindow对象</span><br><span class="line">        if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //若前面没有消费事件，最后交给Activity的onTouchEvent</span><br><span class="line">        return onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的实现很简洁，先交给PhoneWindow分发，如果没有消费事件，则在Activity的onTouchEvent()方法中消费。</p><h3 id="3、PhoneWindow-superDispatchTouchEvent"><a href="#3、PhoneWindow-superDispatchTouchEvent" class="headerlink" title="3、PhoneWindow # superDispatchTouchEvent()"></a>3、PhoneWindow # superDispatchTouchEvent()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">       //mDecor指的是DecorView</span><br><span class="line">       return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入DecorView中的superDispatchTouchEvent()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        return super.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>前面已注明了DecorView是继承自FrameLayout（继承ViewGroup），那么这里也就自然而然的把分发任务交给了ViewGroup的dispatchTouchEvent()。</p><h3 id="4、ViewGroup-dispatchTouchEvent-，由于代码量太长，这里选择关键性的代码"><a href="#4、ViewGroup-dispatchTouchEvent-，由于代码量太长，这里选择关键性的代码" class="headerlink" title="4、ViewGroup # dispatchTouchEvent()，由于代码量太长，这里选择关键性的代码"></a>4、ViewGroup # dispatchTouchEvent()，由于代码量太长，这里选择关键性的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">        // 如果是点击事件，先对之前的状态进行清除</span><br><span class="line">        //1、把mFirstTouchTarget(TouchTarget对象)链表清空，同时mFirstTouchTarget置空</span><br><span class="line">        //mFirstTouchTarget链表内部存放的是接受了触摸事件的view</span><br><span class="line">        //2、重置FLAG_DISALLOW_INTERCEPT标识位(若设置了这个标识，表示禁止ViewGroup的拦截）</span><br><span class="line">        //可以通过requestDisallowInterceptTouchEvent()进行设置，</span><br><span class="line">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查是否进行拦截</span><br><span class="line">        final boolean intercepted;</span><br><span class="line"></span><br><span class="line">        if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != null) &#123;</span><br><span class="line"></span><br><span class="line">            // 检查是否已设置FLAG_DISALLOW_INTERCEPT标识</span><br><span class="line">            // 若设置，则不进行拦截，intercepted为false</span><br><span class="line">            // 否则拦截，由onInterceptTouchEvent()决定intercepted的状态</span><br><span class="line">            // onInterceptTouchEvent()默认返回false</span><br><span class="line">            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">            if (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); // restore action in case it was changed</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                intercepted = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // There are no touch targets and this action is not an initial down</span><br><span class="line">            // so this view group continues to intercept touches.</span><br><span class="line">            intercepted = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">        // 检查当前触摸事件是否被取消</span><br><span class="line">        final boolean canceled = resetCancelNextUpFlag(this)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">        //把当前ViewGrop的触摸事件进行分发给子View和子ViewGroup</span><br><span class="line">        //在这之前需要满足两个条件：1、触摸事件没有取消  2、没有被拦截</span><br><span class="line">        //如果当前ViewGroup的子View接收到触摸事件，则把该子View添加到mFirstTouchTarget链表</span><br><span class="line">        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</span><br><span class="line">        TouchTarget newTouchTarget = null;</span><br><span class="line">        boolean alreadyDispatchedToNewTouchTarget = false;</span><br><span class="line">        if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line"></span><br><span class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                    ? findChildWithAccessibilityFocus() : null;</span><br><span class="line"></span><br><span class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line"></span><br><span class="line">                //记录触摸事件的序列号，事件Id，点击事件的Id总是为0，</span><br><span class="line">                //在多指触控下，会产生多个Id,比如第一根手指，记录0，第二根手机记录1 ~ ~ ~</span><br><span class="line">                final int actionIndex = ev.getActionIndex();</span><br><span class="line">                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                // 清除早期的触摸目标                 </span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                // 获取当前ViewGroup包含的子元素，进行遍历，然后对触摸事件进行分发</span><br><span class="line">                // 如果子元素也是ViewGroup，那么就对其里面的子元素遍历，如此递归下去</span><br><span class="line">                final int childrenCount = mChildrenCount;</span><br><span class="line">                if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</span><br><span class="line">                    final float x = ev.getX(actionIndex);</span><br><span class="line">                    final float y = ev.getY(actionIndex);</span><br><span class="line">                    // Find a child that can receive the event.</span><br><span class="line">                    // Scan children from front to back.</span><br><span class="line">                    final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                    final boolean customOrder = preorderedList == null</span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    final View[] children = mChildren;</span><br><span class="line">                    for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                        final int childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        final View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                        // If there is a view that has accessibility focus we want it</span><br><span class="line">                        // to get the event first and if not handled we will perform a</span><br><span class="line">                        // normal dispatch. We may do a double iteration but this is</span><br><span class="line">                        // safer given the timeframe.</span><br><span class="line">                        if (childWithAccessibilityFocus != null) &#123;</span><br><span class="line">                            if (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                            childWithAccessibilityFocus = null;</span><br><span class="line">                            i = childrenCount - 1;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        //判断子View是否能接收触摸事件</span><br><span class="line">                        if (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 先查找mFirstTouchTarget链表，是否存在该View</span><br><span class="line">                        // 若查找到，则返回当前View在链表中的节点赋值给newTouchTarget</span><br><span class="line">                        // 若没有，则返回null</span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        if (newTouchTarget != null) &#123;</span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        //重置子View的mPrivateFlags中的PFLAG_CANCEL_NEXT_UP_EVENT</span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line"></span><br><span class="line">                        //将触摸事件分发给子View</span><br><span class="line">                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class="line">                            // Child wants to receive touch within its bounds.</span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            if (preorderedList != null) &#123;</span><br><span class="line">                                // childIndex points into presorted list, find original index</span><br><span class="line">                                for (int j = 0; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    if (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        break;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            //若子元素（包含子View和子ViewGroup）可以接收到触摸事件，</span><br><span class="line">                            // 通过addTouchTarget()把已接收触摸事件的子元素添加到</span><br><span class="line">                            //mFirstTouchTarget链表，并把当前子元素作为头结点返回，赋值给newTouchTarget</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // The accessibility focus didn&apos;t handle the event, so clear</span><br><span class="line">                        // the flag and do a normal dispatch to all children.</span><br><span class="line">                        ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (preorderedList != null) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //在newTouchTarget为null，mFirstTouchTarget不为null时，</span><br><span class="line">                //把mFirstTouchTarget赋值给newTouchTarget，作为链表第一个节点</span><br><span class="line">                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</span><br><span class="line">                    // Did not find a child to receive the event.</span><br><span class="line">                    // Assign the pointer to the least recently added target.</span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    while (newTouchTarget.next != null) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">        // 进一步对触摸事件的分发进行处理，mFirstTouchTarget==null表示未有</span><br><span class="line">        // 子View接收到触摸事件，此时，会交由ViewGroup的父类View的dispatchTouchEvent()进行分发，</span><br><span class="line">        //然后再交给onTouch()或onTouchEvent()进行处理</span><br><span class="line">        //onTouch()优先于onTouchEvent()，但是要setOnTouchListener()后才生效</span><br><span class="line">        // 如果mFirstTouchTarget != null，表示存在子View，则分发到子View</span><br><span class="line">        if (mFirstTouchTarget == null) &#123;        </span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Dispatch to touch targets, excluding the new touch target if we already</span><br><span class="line">            // dispatched to it.  Cancel touch targets if necessary.</span><br><span class="line">            TouchTarget predecessor = null;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            while (target != null) &#123;</span><br><span class="line">                final TouchTarget next = target.next;</span><br><span class="line">                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final boolean cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    if (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (cancelChild) &#123;</span><br><span class="line">                        if (predecessor == null) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 完成后重置触摸状态</span><br><span class="line">        if (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            final int actionIndex = ev.getActionIndex();</span><br><span class="line">            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        if(!handled&amp;&amp;mInputEventConsistencyVerifier!=null)&#123;</span><br><span class="line">                mInputEventConsistencyVerifier.onUnhandledEvent(ev,1);</span><br><span class="line">       &#125;</span><br><span class="line">       return handled;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>关于ViewGroup的事件分发，由于代码太长，所以直接在里面注释了，这样跟着代码会比较容易理解。上面阐述了关于ViewGroup的整个分发过程，在第二个省略号的下面一段代码，从其 if 条件可以知道，这段代码只有在ViewGroup发生ACTION_DOWN事件时才会执行(分发事件)，而后续的事件(ACTION_MOVE、ACTION_UP)将由第三个省略号下面一段代码中执行分发，这时会遍历mFirstTouchTarget链表，找到具体的子View进行分配事件。（实际就是：假设当前ViewGroup中包含三个子View，分别是A B C，如果ACTION_DOWN事件分发到了A，那么后续的事件一定不会分发到B或C）<br>下面进一步去分析<strong>dispatchTransformedTouchEvent()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class="line">            View child, int desiredPointerIdBits) &#123;</span><br><span class="line">        final boolean handled;</span><br><span class="line"></span><br><span class="line">        //这里检测是否需要发送ACTION_CANCEL事件。</span><br><span class="line">        final int oldAction = event.getAction();</span><br><span class="line">        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            if (child == null) &#123;    </span><br><span class="line">                //分发给当前ViewGroup</span><br><span class="line">                handled = super.dispatchTouchEvent(event);</span><br><span class="line">            &#125; else &#123;   </span><br><span class="line">               //分发给子View</span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            return handled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计算触摸事件Id</span><br><span class="line">        final int oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">        final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">        if (newPointerIdBits == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        final MotionEvent transformedEvent;</span><br><span class="line">        //若触摸事件Id相同，不需要重新计算MotionEvent，直接进行分发</span><br><span class="line">        if (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">            if (child == null || child.hasIdentityMatrix()) &#123;</span><br><span class="line">                //child为null，交由父类分发，否则交由child分发</span><br><span class="line">                if (child == null) &#123;</span><br><span class="line">                    handled = super.dispatchTouchEvent(event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final float offsetX = mScrollX - child.mLeft;</span><br><span class="line">                    final float offsetY = mScrollY - child.mTop;</span><br><span class="line">                    event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                    handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                    event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">                &#125;</span><br><span class="line">                return handled;</span><br><span class="line">            &#125;</span><br><span class="line">            transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Perform any necessary transformations and dispatch.</span><br><span class="line">        if (child == null) &#123;</span><br><span class="line">            handled = super.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final float offsetX = mScrollX - child.mLeft;</span><br><span class="line">            final float offsetY = mScrollY - child.mTop;</span><br><span class="line">            transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">            if (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">                transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Done.</span><br><span class="line">        transformedEvent.recycle();</span><br><span class="line">        return handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在dispatchTransformedTouchEvent()中主要是对子View进行判断，如果子View为null，则分发交由super.dispatchTouchEvent()，也就是由View的dispatchTouchEvent()分发，然后交给onTouch()(如果设置了OnTouchListener)或onTouchEvent()，如果这时候onTouchEvent()依旧返回false，则交由当前ViewGroup的上一级去处理。</p><h3 id="5、View-dispatchTouchEvent-，省略了部分代码"><a href="#5、View-dispatchTouchEvent-，省略了部分代码" class="headerlink" title="5、View # dispatchTouchEvent()，省略了部分代码"></a>5、View # dispatchTouchEvent()，省略了部分代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">       ... ...</span><br><span class="line"></span><br><span class="line">        final int actionMasked = event.getActionMasked();</span><br><span class="line">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            // 接收到ACTION_DOWN，停止嵌套滑动</span><br><span class="line">            stopNestedScroll();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         //判断View是否被屏蔽，是否能被点击，</span><br><span class="line">        //然后再确定是否执行onTouch或onTouchEvent</span><br><span class="line">        if (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //在这里注意下li.mOnTouchListener.onTouch()，这里说明了</span><br><span class="line">            //onTouch会先于onTouchEvent执行，前提：当前View设置了OnTouchListener</span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            if (li != null &amp;&amp; li.mOnTouchListener != null</span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //若没有设置OnTouchListener，交给onTouchEvent</span><br><span class="line">            if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关键的步骤已在代码中注释，就不再另外赘述了。<br>接着看下View的onTouchEvent()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        final float x = event.getX();</span><br><span class="line">        final float y = event.getY();</span><br><span class="line">        final int viewFlags = mViewFlags;</span><br><span class="line">        final int action = event.getAction();</span><br><span class="line">        </span><br><span class="line">        //计算View是否可点击</span><br><span class="line">        final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line">        </span><br><span class="line">        //这里View被禁用，调用了setEnabled(false)或android:enabled=false</span><br><span class="line">        //返回其点击状态，View默认是不可点击的</span><br><span class="line">        //可以通过setClickable()或者android:clickable设置点击状态</span><br><span class="line">        if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</span><br><span class="line">                setPressed(false);</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;        </span><br><span class="line">            return clickable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //委托事件给其它View，mTouchDelegate默认为null</span><br><span class="line">        if (mTouchDelegate != null) &#123;</span><br><span class="line">            if (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断View的点击状态，设置焦点。后续执行onClick()、onLongClick()</span><br><span class="line">        if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">            switch (action) &#123;</span><br><span class="line">                case MotionEvent.ACTION_UP:</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">                        handleTooltipUp();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!clickable) &#123;</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        mInContextButtonPress = false;</span><br><span class="line">                        mHasPerformedLongPress = false;</span><br><span class="line">                        mIgnoreNextUpEvent = false;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;</span><br><span class="line">                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;</span><br><span class="line">                        // take focus if we don&apos;t have it already and we should in</span><br><span class="line">                        // touch mode.</span><br><span class="line">                        boolean focusTaken = false;</span><br><span class="line">                        if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (prepressed) &#123;</span><br><span class="line">                            // The button is being released before we actually</span><br><span class="line">                            // showed it as pressed.  Make it show the pressed</span><br><span class="line">                            // state now (before scheduling the click) to ensure</span><br><span class="line">                            // the user sees it.</span><br><span class="line">                            setPressed(true, x, y);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            // This is a tap, so remove the longpress check</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                            // Only perform take click actions if we were in the pressed state</span><br><span class="line">                            if (!focusTaken) &#123;</span><br><span class="line">                                // Use a Runnable and post this rather than calling</span><br><span class="line">                                // performClick directly. This lets other visual state</span><br><span class="line">                                // of the view update before click actions start.</span><br><span class="line">                                if (mPerformClick == null) &#123;</span><br><span class="line">                                    mPerformClick = new PerformClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (!post(mPerformClick)) &#123;</span><br><span class="line">                                    performClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (mUnsetPressedState == null) &#123;</span><br><span class="line">                            mUnsetPressedState = new UnsetPressedState();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (prepressed) &#123;</span><br><span class="line">                            postDelayed(mUnsetPressedState,</span><br><span class="line">                                    ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                        &#125; else if (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                            // If the post failed, unpress right now</span><br><span class="line">                            mUnsetPressedState.run();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mIgnoreNextUpEvent = false;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case MotionEvent.ACTION_DOWN:</span><br><span class="line">                    if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;</span><br><span class="line">                        mPrivateFlags3 |= PFLAG3_FINGER_DOWN;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mHasPerformedLongPress = false;</span><br><span class="line"></span><br><span class="line">                    if (!clickable) &#123;</span><br><span class="line">                        checkForLongClick(0, x, y);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.</span><br><span class="line">                    boolean isInScrollingContainer = isInScrollingContainer();</span><br><span class="line"></span><br><span class="line">                    // For views inside a scrolling container, delay the pressed feedback for</span><br><span class="line">                    // a short period in case this is a scroll.</span><br><span class="line">                    if (isInScrollingContainer) &#123;</span><br><span class="line">                        mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                        if (mPendingCheckForTap == null) &#123;</span><br><span class="line">                            mPendingCheckForTap = new CheckForTap();</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPendingCheckForTap.x = event.getX();</span><br><span class="line">                        mPendingCheckForTap.y = event.getY();</span><br><span class="line">                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // Not inside a scrolling container, so show the feedback right away</span><br><span class="line">                        setPressed(true, x, y);</span><br><span class="line">                        checkForLongClick(0, x, y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case MotionEvent.ACTION_CANCEL:</span><br><span class="line">                    if (clickable) &#123;</span><br><span class="line">                        setPressed(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    mInContextButtonPress = false;</span><br><span class="line">                    mHasPerformedLongPress = false;</span><br><span class="line">                    mIgnoreNextUpEvent = false;</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case MotionEvent.ACTION_MOVE:</span><br><span class="line">                    if (clickable) &#123;</span><br><span class="line">                        drawableHotspotChanged(x, y);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Be lenient about moving outside of buttons</span><br><span class="line">                    if (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                        // Outside button</span><br><span class="line">                        // Remove any future long press/tap checks</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</span><br><span class="line">                            setPressed(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关于View的事件分发大概流程到这里就结束了。<br>Activity &gt;  ViewGroup(可包含多个ViewGroup) &gt; View 。<br>最后通过一张图的形式整理下上面的思路：<br><img src="https://upload-images.jianshu.io/upload_images/6271454-2bd0e0b3fce383b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View的事件分发.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;View的事件分发所针对的是MotionEvent事件，在Touch过程中会产生大量的MotionEvent，记录了与Touch相关的事件。一次ACTION_DOWN、中间可能多次ACTION_MOVE、一次ACTION_UP，这便是一次完整的MotionEvent事件。在
      
    
    </summary>
    
      <category term="View系列" scheme="http://yoursite.com/categories/View%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="View" scheme="http://yoursite.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="http://yoursite.com/2018/05/20/%E6%8E%A2%E7%B4%A2Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/05/20/探索Java-线程池/</id>
    <published>2018-05-20T00:28:16.000Z</published>
    <updated>2018-05-20T01:21:17.313Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多线程可以说是开发应用程序的标配了，在Java中通常情况都是通过new Thread()来创建一个工作线程，如果需要并发执行任务时，以这种方式创建线程，由于线程的频繁创建和销毁，会消耗大量的系统资源，程序出现卡顿，甚至出现OOM。因此，Java中利用了线程池，它通过对已存在线程的重用，降低了线程创建和销毁所造成的资源消耗，可以自己控制并发数，不必等待新线程的创建时间便执行任务，提高了系统的响应速度。</p></blockquote><p>Java通过Executors这个类，提供了四种线程池：</p><blockquote><ul><li>newFixedThreadPool()</li><li>newSingleThreadExecutor()</li><li>newCachedThreadPool()</li><li>newScheduledThreadPool()</li></ul></blockquote><p>下面分别会为这四种不同方式创建的线程池进行分析，在此之前，先看一段ThreadPoolExecutor的构造方法源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor是Java线程池中的核心类，上面四种创建线程池的方式也是通过ThreadPoolExecutor类完成的，并且以静态工厂方法模式封装在了Executors这个类中。这个构造函数是包含参数最多的，都是ThreadPoolExecutor类的关键属性。看下面分析：</p><blockquote><ul><li>corePoolSize：核心线程数，必须大于或等于0</li><li>maximumPoolSize：线程池的最大线程数，必须大于1</li><li>keepAliveTime：线程在空闲时候的存活时间，必须大于或等于0</li><li>TimeUnit：存活的时间单位</li><li>workQueue：线程池中的任务队列，不能为空</li><li>threadFactory：线程工厂，不能为空</li><li>handler：线程饱和策略，不能为空</li></ul><p><strong>注意：</strong>在创建线程池时，后面的条件限制必须满足，否则异常。对于参数少的构造方法，threadFactory和handler会使用默认。</p></blockquote><h5 id="对于这几个属性简单了解后，接着分析之前提到的四种线程池"><a href="#对于这几个属性简单了解后，接着分析之前提到的四种线程池" class="headerlink" title="对于这几个属性简单了解后，接着分析之前提到的四种线程池"></a>对于这几个属性简单了解后，接着分析之前提到的四种线程池</h5><h1 id="1、newFixedThreadPool"><a href="#1、newFixedThreadPool" class="headerlink" title="1、newFixedThreadPool()"></a>1、newFixedThreadPool()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void fixPool()&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            int finalI = i;</span><br><span class="line">            executorService.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);   </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot; --- &quot;+ finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//...1   Executors类newFixedThreadPool()源码</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2 --- 1</span><br><span class="line">pool-1-thread-1 --- 0</span><br><span class="line">pool-1-thread-3 --- 2</span><br><span class="line">pool-1-thread-1 --- 4</span><br><span class="line">pool-1-thread-2 --- 3</span><br></pre></td></tr></table></figure><p>在上面代码注释1处可以知道，用newFixedThreadPool()创建的线程池，其核心线程数和最大线程数是相同的，且无超时限制(线程空闲是不会被终止(回收))。采用了LinkedBlockingQueue无界队列。根据输出结果分析：当添加前三个任务时，若无空闲线程的情况下会创建一个新的线程去执行任务。当达到创建线程池时设定的核心线程数后，后续的任务会被放进无界队列LinkedBlockingQueue中，等待前面的线程执行完成后才进行提交。</p><h1 id="2、newSingleThreadExecutor"><a href="#2、newSingleThreadExecutor" class="headerlink" title="2、newSingleThreadExecutor()"></a>2、newSingleThreadExecutor()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void singlePool()&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            final int finalI = i;</span><br><span class="line">            executorService.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;  &quot;+ finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// Executors类newSingleThreadExecutor()源码</span><br><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1  0</span><br><span class="line">pool-1-thread-1  1</span><br><span class="line">pool-1-thread-1  2</span><br><span class="line">pool-1-thread-1  3</span><br><span class="line">pool-1-thread-1  4</span><br></pre></td></tr></table></figure><p>newSingleThreadExecutor()创建一个单线程的线程池，根据输出结果分析：串行的执行任务，若线程处于工作状态，任务会被放进无界队列LinkedBlockingQueue中，等待前面任务执行完成才会提交。</p><h1 id="3、newCachedThreadPool"><a href="#3、newCachedThreadPool" class="headerlink" title="3、newCachedThreadPool()"></a>3、newCachedThreadPool()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void cachePool()&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            final int finalI = i;</span><br><span class="line">            executorService.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot; --- &quot;+ finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// Executors类newCachedThreadPool()源码</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 --- 0</span><br><span class="line">pool-1-thread-3 --- 2</span><br><span class="line">pool-1-thread-2 --- 1</span><br><span class="line">pool-1-thread-5 --- 4</span><br><span class="line">pool-1-thread-4 --- 3</span><br></pre></td></tr></table></figure><p>newCachedThreadPool()创建的线程池，核心线程数是0；最大线程数是最大常数。设定了线程空闲时的存活时间为60s；SynchronousQueue队列不会存放任务，任务到来时就会被提交，执行。从输出结果可以发现：我们提交了5个任务，直接创建了5个线程进行执行。但是，在提交新任务时，如果有存在空闲的线程，则会重用这个空闲线程。我们改下上面代码，再看下输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void cachePool()&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            final int finalI = i;</span><br><span class="line">            executorService.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot; --- &quot;+ finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">           //每隔一秒提交一次</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 --- 0</span><br><span class="line">pool-1-thread-2 --- 1</span><br><span class="line">pool-1-thread-1 --- 2</span><br><span class="line">pool-1-thread-2 --- 3</span><br><span class="line">pool-1-thread-1 --- 4</span><br></pre></td></tr></table></figure><h1 id="4、newScheduledThreadPool"><a href="#4、newScheduledThreadPool" class="headerlink" title="4、newScheduledThreadPool()"></a>4、newScheduledThreadPool()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> private void scheduledPool()&#123;</span><br><span class="line">        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3);</span><br><span class="line">        executorService.schedule(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;延时执行&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,2, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// Executors类newScheduledThreadPool()源码</span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//ScheduledExecutorService的构造方法</span><br><span class="line">  public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">        super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              new DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>newScheduledThreadPool()创建的线程池，核心线程数自定义，最大线程数为最大常数。空闲时的存活时间默认DEFAULT_KEEPALIVE_MILLIS = 10ms，DelayedWorkQueue延时队列。上面的代码创建的是延时执行一次任务。还可利用scheduleAtFixedRate创建一个定时循环执行任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3);</span><br><span class="line">        executorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;定时循环执行&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,10,3000, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>上面代码，创建了一个定时循环执行任务的线程池。初始执行延迟10ms，后续每一次任务相隔3000ms。<br>scheduleAtFixedRate和scheduleWithFixedDelay类似，其中的区别：scheduleAtFixedRate的相隔时间是上个线程执行开始到下个线程执行开始的时间。<br>scheduleWithFixedDelay的相隔时间是上个线程执行结束到下个线程执行开始的时间。</p><h6 id="除了上面四种方式创建线程池，我们也可以通过ThreadPoolExecutor类自定义创建线程池，下面看一段AsyncTask中的源码-自定义线程池"><a href="#除了上面四种方式创建线程池，我们也可以通过ThreadPoolExecutor类自定义创建线程池，下面看一段AsyncTask中的源码-自定义线程池" class="headerlink" title="除了上面四种方式创建线程池，我们也可以通过ThreadPoolExecutor类自定义创建线程池，下面看一段AsyncTask中的源码(自定义线程池)"></a>除了上面四种方式创建线程池，我们也可以通过ThreadPoolExecutor类自定义创建线程池，下面看一段AsyncTask中的源码(自定义线程池)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line">private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));</span><br><span class="line">private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;</span><br><span class="line">private static final int KEEP_ALIVE_SECONDS = 30;</span><br><span class="line"></span><br><span class="line"> ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">                sPoolWorkQueue, sThreadFactory);</span><br><span class="line">        //允许核心线程超时终止</span><br><span class="line">        threadPoolExecutor.allowCoreThreadTimeOut(true);</span><br><span class="line"></span><br><span class="line">//sPoolWorkQueue</span><br><span class="line">private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</span><br><span class="line">            new LinkedBlockingQueue&lt;Runnable&gt;(128);</span><br><span class="line"></span><br><span class="line">//sThreadFactory</span><br><span class="line">private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123;</span><br><span class="line">        private final AtomicInteger mCount = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">        public Thread newThread(Runnable r) &#123;</span><br><span class="line">            return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h1 id="线程池的关闭："><a href="#线程池的关闭：" class="headerlink" title="线程池的关闭："></a>线程池的关闭：</h1><p>利用shutdown()或shutdownNow()关闭线程池</p><blockquote><ul><li>shutdown()：把线程池的状态设置为SHUTDOWN状态，中断所有没有正在执行任务的线程池。</li><li>shutdownNow()：把线程池的状态设置为STOP状态，中断所有的线程，包括正在执行任务的线程。</li></ul></blockquote><h1 id="前面对线程池几个属性和创建方式进行了简单的阐述，下面再对几个属性进行详解："><a href="#前面对线程池几个属性和创建方式进行了简单的阐述，下面再对几个属性进行详解：" class="headerlink" title="前面对线程池几个属性和创建方式进行了简单的阐述，下面再对几个属性进行详解："></a>前面对线程池几个属性和创建方式进行了简单的阐述，下面再对几个属性进行详解：</h1><blockquote><ul><li>corePoolSize（核心线程数）：若线程池中的线程数小于corePoolSize，这时提交任务会创建新的线程执行。若大于或等于corePoolSize，提交任务时会根据是否存在空闲线程，决定是否创建新的线程来执行任务。也可以通过prestartCoreThread()或prestartAllCoreThreads()提前启动核心线程。</li></ul></blockquote><blockquote><ul><li>maximumPoolSize（最大线程数）：线程池中允许的最大线程数量，如果线程池的队列已满，且线程数小于maximumPoolSize，会创建新的线程执行任务，否则会被拒绝（RejectedExecutionException）</li></ul></blockquote><blockquote><ul><li>keepAliveTime（线程空闲存活时间）：这个超时限制是对超过corePoolSize的线程的控制，如果核心线程也要实现这个机制，可以利用allowCoreThreadTimeOut(true)进行设置</li></ul></blockquote><blockquote><ul><li>TimeUnit（单位时间）：NANOSECONDS（纳秒），MICROSECONDS（微妙），MILLISECONDS（毫秒），SECONDS（秒），MINUTES（分），HOURS（小时），DAYS（天）；</li></ul></blockquote><blockquote><ul><li>BlockingQueue（任务队列）：存放等待执行任务的阻塞队列。在线程数小于corePoolSize时，会创建新线程执行任务，不会进行排队。大于corePoolSize时，任务会添加到队列。若队列已满，且线程数不超过maximumPoolSize，则会创建新线程执行任务。否则会被拒绝。</li></ul></blockquote><blockquote><ul><li>ThreadFactory（线程工厂）：用于创建新的线程，设置线程优先级。</li></ul></blockquote><blockquote><ul><li>RejectedExecutionHandler（线程饱和策略）：<br>ThreadPoolExecutor.AbortPolicy：处理程序遭到拒绝，则直接抛出运行时异常 RejectedExecutionException。(默认策略)<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程执行该任务。策略实现了一种调节机制，不会抛弃任务，也不会抛出异常。<br>ThreadPoolExecutor.DiscardPolicy：无法执行的任务将被删除。<br>ThreadPoolExecutor.DiscardOldestPolicy：会先丢弃保存时间最长的任务(队列列头开始)，然后尝试添加新任务（失败后会重复前面的步骤）</li></ul></blockquote><h1 id="常见的工作队列-BlockingQueue-："><a href="#常见的工作队列-BlockingQueue-：" class="headerlink" title="常见的工作队列(BlockingQueue)："></a>常见的工作队列(BlockingQueue)：</h1><blockquote><ul><li>ArrayBlockingQueue ：基于数组的有界阻塞队列，当队列已满后添加会遭到拒绝。</li><li>LinkedBlockingQueue：基于链表的无界阻塞队列（默认），但可以通过构造函数去实现有固定长度的队列。</li><li>SynchronousQueue：一种直接提交策略，特性：添加一次任务，必须等待线程取走这次任务后才能添加其它任务。</li><li>PriorityBlockingQueue：优先级阻塞队列，插入元素时会按照定义的排序规则来对元素数组进行排序，入队的元素必须实现Comparable接口，执行时优先级高的会先被取出。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;多线程可以说是开发应用程序的标配了，在Java中通常情况都是通过new Thread()来创建一个工作线程，如果需要并发执行任务时，以这种方式创建线程，由于线程的频繁创建和销毁，会消耗大量的系统资源，程序出现卡顿，甚至出现OOM。因此，Java中利
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="ThreadPool" scheme="http://yoursite.com/tags/ThreadPool/"/>
    
      <category term="Java线程" scheme="http://yoursite.com/tags/Java%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
