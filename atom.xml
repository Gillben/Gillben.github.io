<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gillben Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-16T15:34:34.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gillben</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/05/16/EventBus%EF%BC%883-1-1%EF%BC%89%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2018/05/16/EventBus（3-1-1）源码浅析/</id>
    <published>2018-05-16T15:34:34.000Z</published>
    <updated>2018-05-16T15:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>#前言</p><blockquote><p>EventBus是Android的发布/订阅事件总线，通过对发送者和接收者的解耦，简化了Android的事件传递。提高了代码的简洁性。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6271454-96ec281d43217d8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方图.png"></p><p>#####1、EventBus的简单使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends BaseActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        //注册</span><br><span class="line">        EventBus.getDefault().register(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Subscribe(threadMode = ThreadMode.MAIN)</span><br><span class="line">    public void receiveEventBusMessage(EventBusMessage message)&#123;</span><br><span class="line">        Log.e(&quot;receive&quot;, &quot;receiveEventBusMessage: &quot;+message.getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        //解注册</span><br><span class="line">        EventBus.getDefault().unregister(this);     </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可以在其它组件、fragment或工作线程中发送事件</span><br><span class="line">private void sendMessage()&#123;</span><br><span class="line">        EventBus.getDefault().post(new EventBusMessage(&quot;消息：&quot;+ new Random().nextInt(50)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>从上面代码可以发现，EventBus实现事件传递有多简洁，无任何花哨。首先，通过register()进行注册，这是使用EventBus的前提；然后声明一个订阅方法用于事件的接收(利用<strong>@Subscribe</strong>注解)，threadMode指定线程模式(在这里指定于主线程)，其中EventBusMessage是自己定义一个事件类；再然后通过在其它组件、Fragment或工作线程中使用post()发送事件，这样就完成了事件的传递。当组件销毁或者EventBus不再使用时千万别忘记了unregister()解注册。<strong>这很重要！！！</strong></p><p>#####2、经过上面的一个简单分析，初步的了解了EventBus的使用。那么，看似简单的几个步骤，里面究竟蕴含了什么内功心法或者招式呢？（故事说起来就长了）前排准备瓜子顺带点小酒。接下来从EventBus.getDefault()开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> public static EventBus getDefault() &#123;</span><br><span class="line">        if (defaultInstance == null) &#123;</span><br><span class="line">            synchronized (EventBus.class) &#123;</span><br><span class="line">                if (defaultInstance == null) &#123;</span><br><span class="line">                    defaultInstance = new EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return defaultInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//EventBusBuilder以建造者模式初始化一以下属性</span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">        logger = builder.getLogger();</span><br><span class="line">        subscriptionsByEventType = new HashMap&lt;&gt;();    //订阅的事件类型</span><br><span class="line">        typesBySubscriber = new HashMap&lt;&gt;();           //订阅类型</span><br><span class="line">        stickyEvents = new ConcurrentHashMap&lt;&gt;();      //粘性事件</span><br><span class="line">        mainThreadSupport = builder.getMainThreadSupport(); //主线程接口类</span><br><span class="line">        mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;</span><br><span class="line">        backgroundPoster = new BackgroundPoster(this); //在后台提交的事件</span><br><span class="line">        asyncPoster = new AsyncPoster(this);</span><br><span class="line">        indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;</span><br><span class="line">        //查找订阅方法的类</span><br><span class="line">        subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">        logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">        logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">        throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">        eventInheritance = builder.eventInheritance;</span><br><span class="line">        //获取一个线程池</span><br><span class="line">        executorService = builder.executorService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>很清晰，EventBus.getDefault()利用了单例模式中的双重校验方式获取一个EventBus实例。在构造函数最后一步通过Executors.newCachedThreadPool()创建一个线程池（主要在后台任务或异步任务时使用），对于线程池的创建可以了解这篇文章【<a href="https://www.jianshu.com/p/04827fafb71a" target="_blank" rel="noopener">探索Java 线程池</a>】</p><p>#####3、EventBus的注册过程(register)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        //获取一个订阅方法List，包含了所订阅的类声明的订阅方法</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中可以知道，做了两件事，<br>1、查找订阅的方法，SubscriberMethodFinder # findSubscriberMethods()<br>2、进行订阅。subscribe()</p><p><strong>3.1、是如何查找已声明的订阅方法？进入SubscriberMethodFinder类的indSubscriberMethods()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">       //1</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">        if (subscriberMethods != null) &#123;</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ignoreGeneratedIndex) &#123; //2</span><br><span class="line">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                    + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">        &#125; else &#123; //3</span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在上面代码1处，首先会从缓存中查找，subscriberClass正是调用register()注册的订阅者，METHOD_CACHE是一个ConcurrentHashMap的实例，从这里可以知道，subscriberClass作为ConcurrentHashMap的key，而ConcurrentHashMap的value（List<subscribermethod>）存放的是当前订阅者中声明的订阅方法。注释2处表示是否忽略索引的位置，默认为false，因此会在通过findUsingInfo()查找，注释3处把找到的方法保存到METHOD_CACHE中。一起研究findUsingInfo()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">       //从对象池中寻找FindState实例（数组的形式实现对象池）</span><br><span class="line">       FindState findState = prepareFindState();</span><br><span class="line">       //初始化需要寻找的方法的所属类</span><br><span class="line">       findState.initForSubscriber(subscriberClass);</span><br><span class="line">       while (findState.clazz != null) &#123;</span><br><span class="line">         //找到后，获取订阅者的信息 </span><br><span class="line">           findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">          //开始保存获取的订阅方法</span><br><span class="line">           if (findState.subscriberInfo != null) &#123;</span><br><span class="line">               SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">               for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                   if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                       findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //如果上面没有找到，则通过反射、注解的方式寻找</span><br><span class="line">               findUsingReflectionInSingleClass(findState);</span><br><span class="line">           &#125;</span><br><span class="line">           //移动到父类</span><br><span class="line">           findState.moveToSuperclass();</span><br><span class="line">       &#125;</span><br><span class="line">       return getMethodsAndRelease(findState); //找到方法后释放findState</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></subscribermethod></p><p>经过上面代码注释，对寻找订阅方法的步骤已经很清晰了，下面贴出getSubscriberInfo()和findUsingReflectionInSingleClass()两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private SubscriberInfo getSubscriberInfo(FindState findState) &#123;</span><br><span class="line">       if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123;</span><br><span class="line">           SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">           //判断是否是需要寻找的具体类</span><br><span class="line">           if (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">               return superclassInfo;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //通过订阅信息索引进行查找</span><br><span class="line">       if (subscriberInfoIndexes != null) &#123;</span><br><span class="line">           for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">               SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">               if (info != null) &#123;</span><br><span class="line">                   return info;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        try &#123;</span><br><span class="line">            // This is faster than getMethods, especially when subscribers are fat classes like Activities</span><br><span class="line">            methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; catch (Throwable th) &#123;</span><br><span class="line">            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses = true;</span><br><span class="line">        &#125;</span><br><span class="line">      //遍历订阅者中的所有方法</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            int modifiers = method.getModifiers();</span><br><span class="line">            //对订阅方法的作用域进行判断</span><br><span class="line">            if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                if (parameterTypes.length == 1) &#123;</span><br><span class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                    if (subscribeAnnotation != null) &#123;</span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[0];</span><br><span class="line">                        if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                    String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                    throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                            &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                throw new EventBusException(methodName +</span><br><span class="line">                        &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3.2、是如何进行订阅的？subscribe()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line"></span><br><span class="line">        //通过订阅者和订阅方法创建一个订阅事件</span><br><span class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</span><br><span class="line"></span><br><span class="line">        //根据eventType从缓存中获取subscriptions</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line"></span><br><span class="line">        //若缓存中没有，则添加到缓存</span><br><span class="line">        if (subscriptions == null) &#123;</span><br><span class="line">            subscriptions = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         //遍历订阅事件，根据优先级重新排序</span><br><span class="line">        int size = subscriptions.size();</span><br><span class="line">        for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line">            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        //这里根据订阅者查找EventType缓存</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        if (subscribedEvents == null) &#123;</span><br><span class="line">            subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line">        </span><br><span class="line">        //对粘性进行处理</span><br><span class="line">        if (subscriberMethod.sticky) &#123;</span><br><span class="line">            if (eventInheritance) &#123;      //同时考虑子类</span><br><span class="line">                // Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">                // Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">                // thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">                // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码，就是整个的订阅过程了，比较关键的两个东西subscriptionsByEventType和typesBySubscriber，首先把订阅者和订阅方法封装进subscriptionsByEventType，当post事件时根据eventType查找具体的订阅者，然后进行处理。而typesBySubscriber存放的订阅者，在解注册时根据订阅者查找对应的eventType。在最后，会判断是否是粘性事件，如果是，则立刻进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) &#123;</span><br><span class="line">      if (stickyEvent != null) &#123;    </span><br><span class="line">          //post事件是最终也调用这个方法，所以在下一步进行分析</span><br><span class="line">          postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>#####4、发送事件 post()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void post(Object event) &#123;</span><br><span class="line">        //每个线程都有一个提交事件的状态</span><br><span class="line">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">        eventQueue.add(event);    //把提交的事件对象添加到eventQueue</span><br><span class="line"></span><br><span class="line">        if (!postingState.isPosting) &#123;</span><br><span class="line">            postingState.isMainThread = isMainThread();</span><br><span class="line">            postingState.isPosting = true;</span><br><span class="line">            if (postingState.canceled) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 2</span><br><span class="line">            try &#123;</span><br><span class="line">                while (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                    postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                postingState.isPosting = false;</span><br><span class="line">                postingState.isMainThread = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>从上面代码可以发现，首先根据PostingThreadState确定当前线程的提交状态，从PostingThreadState获取eventQueue，用于存放提交的事件；然后会在注释2处，对事件进行遍历，直到eventQueue内部元素为空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</span><br><span class="line">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">        boolean subscriptionFound = false;</span><br><span class="line">        //考虑子类</span><br><span class="line">        if (eventInheritance) &#123;</span><br><span class="line">            //查找所有的EventType</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">            int countTypes = eventTypes.size();</span><br><span class="line"></span><br><span class="line">            //遍历，对eventTypes内部逐一处理</span><br><span class="line">            for (int h = 0; h &lt; countTypes; h++) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!subscriptionFound) &#123;</span><br><span class="line">            if (logNoSubscriberMessages) &#123;</span><br><span class="line">                logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);</span><br><span class="line">            &#125;</span><br><span class="line">            if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                    eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">                post(new NoSubscriberEvent(this, event));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，先查找出所有的EventType，然后通过postSingleEventForEventType()逐个逐个的处理，postSingleEventForEventType()内部又调用了postToSubscription()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">        switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            case POSTING:</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            case MAIN:</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case MAIN_ORDERED:</span><br><span class="line">                if (mainThreadPoster != null) &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // temporary: technically not correct as poster not decoupled from subscriber</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case BACKGROUND:</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>分析到这里，可以知道，会根据在最初声明的订阅方法中标识的threadMode进行对应处理，这里就选择文章第一步中的MAIN标识进行分析。<br>1、isMainThread为true，表示在主线程中执行，直接调用invokeSubscriber()。<br>2、若不在主线程执行，调用mainThreadPoster.enqueue()，mainThreadPoster实际是HandlerPoster(继承了Handler)类对象的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//HandlerPoster # enqueue()</span><br><span class="line"> public void enqueue(Subscription subscription, Object event) &#123;</span><br><span class="line">        //把订阅者和提交的事件封装在pendingPost</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            //内部利用了单向链表的方式进行摆放</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            if (!handlerActive) &#123;</span><br><span class="line">                handlerActive = true;</span><br><span class="line">                if (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    throw new EventBusException(&quot;Could not send handler message&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //HandlerPoster # handleMessage()</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        boolean rescheduled = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            long started = SystemClock.uptimeMillis();</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                PendingPost pendingPost = queue.poll();</span><br><span class="line">                if (pendingPost == null) &#123;</span><br><span class="line">                    synchronized (this) &#123;</span><br><span class="line">                        // Check again, this time in synchronized</span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        if (pendingPost == null) &#123;</span><br><span class="line">                            handlerActive = false;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                long timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">                if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                    if (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                        throw new EventBusException(&quot;Could not send handler message&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rescheduled = true;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            handlerActive = rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>根据上面HandlerPoster中的两段代码发现，最终是以Handler消息机制的方式进行处理事件，其中HandlerPoster的Looper是在初始化EventBus的时候获取了主线程中的Looper对象，在MainThreadSupport的实现类AndroidHandlerMainThreadSupport中。最后在handleMessage()中轮询queue，queue是PendingPostQueue的一个实例。调用poll()获取pendingPost，再调用eventBus.invokeSubscriber()进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> synchronized PendingPost poll() &#123;</span><br><span class="line">        PendingPost pendingPost = head;</span><br><span class="line">        //从链表头部head开始，取完后就移除，下一个链节点作为head，如此循环</span><br><span class="line">        if (head != null) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            if (head == null) &#123;</span><br><span class="line">                tail = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pendingPost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//从链表中获取消息后的处理</span><br><span class="line">void invokeSubscriber(PendingPost pendingPost) &#123;</span><br><span class="line">        Object event = pendingPost.event;</span><br><span class="line">        Subscription subscription = pendingPost.subscription;</span><br><span class="line">        PendingPost.releasePendingPost(pendingPost);  //释放PendingPost</span><br><span class="line">        if (subscription.active) &#123;</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在（threadMode == MAIN）时，经过上面的分析可以知道，不管是在主线程调用，还是工作线程中(通过Handler机制处理消息)，都是调用了EventBus # invokeSubscriber(Subscription subscription, Object event) 这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void invokeSubscriber(Subscription subscription, Object event) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //通过反射进行处理</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>#####5、解注册unregister()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void unregister(Object subscriber) &#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">        if (subscribedTypes != null) &#123;</span><br><span class="line">            for (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">                unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">            &#125;</span><br><span class="line">            typesBySubscriber.remove(subscriber);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">        List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        if (subscriptions != null) &#123;</span><br><span class="line">            int size = subscriptions.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                Subscription subscription = subscriptions.get(i);</span><br><span class="line">                if (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                    subscription.active = false;</span><br><span class="line">                    subscriptions.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>解注册的过程就比较简单了，还记得提交事件时讲到的typesBySubscriber吗？里面以键值对的形式存储subscriber和eventType的List。因此，在这根据订阅者subscriber找到eventType的List，然后遍历，进行释放。<br><strong>完篇</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#前言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;EventBus是Android的发布/订阅事件总线，通过对发送者和接收者的解耦，简化了Android的事件传递。提高了代码的简洁性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/05/15/hello-world/"/>
    <id>http://yoursite.com/2018/05/15/hello-world/</id>
    <published>2018-05-15T13:54:18.947Z</published>
    <updated>2018-05-15T13:54:18.947Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
