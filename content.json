{"meta":{"title":"Gillben","subtitle":null,"description":null,"author":"Gillben","url":"http://gillben.cn"},"pages":[{"title":"About","date":"2018-07-11T13:43:01.146Z","updated":"2018-07-11T13:00:37.191Z","comments":true,"path":"about/index.html","permalink":"http://gillben.cn/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-07-11T13:43:09.367Z","updated":"2018-07-11T13:00:37.191Z","comments":true,"path":"categories/index.html","permalink":"http://gillben.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-07-11T13:43:01.163Z","updated":"2018-07-11T13:00:37.192Z","comments":true,"path":"tags/index.html","permalink":"http://gillben.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OkHttp3源码解析 连接池的复用","slug":"OkHttp3/OkHttp3-源码解析-连接池的复用","date":"2018-05-22T14:26:06.000Z","updated":"2018-07-12T12:43:34.087Z","comments":true,"path":"2018/05/22/OkHttp3/OkHttp3-源码解析-连接池的复用/","link":"","permalink":"http://gillben.cn/2018/05/22/OkHttp3/OkHttp3-源码解析-连接池的复用/","excerpt":"OkHttp3系列文章 OkHttp3 源码解析执行流程 OkHttp3 源码解析内部缓存 本文将对OkHttp3的连接池的复用进行深一步的分析，我们知道，Http是基于TCP协议的，而TCP建立连接需要经过三次握手，断开需要经过四次挥手，因此，Http中添加了一种KeepAlive机制，当数据传输完毕后仍然保持连接，等待下一次请求时直接复用该连接。通过对连接池的管理，复用连接，减少了频繁的网络请求导致性能下降的问题。","text":"OkHttp3系列文章 OkHttp3 源码解析执行流程 OkHttp3 源码解析内部缓存 本文将对OkHttp3的连接池的复用进行深一步的分析，我们知道，Http是基于TCP协议的，而TCP建立连接需要经过三次握手，断开需要经过四次挥手，因此，Http中添加了一种KeepAlive机制，当数据传输完毕后仍然保持连接，等待下一次请求时直接复用该连接。通过对连接池的管理，复用连接，减少了频繁的网络请求导致性能下降的问题。 找到获取连接的入口，ConnectInterceptor的intercept()方法12345678910111213public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); // 1 HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125; 在注释1处利用StreamAllocation的newStream()获取httpCodec对象，这个过程会从连接池中寻找是否有可用连接，若有，则返回；若没有，则创建一个新的连接，并加入连接池中。 newStream()的内部实现123456789101112131415161718192021public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try &#123; RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) &#123; codec = resultCodec; return resultCodec; &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125; &#125; 在newStream()内部调用findHealthyConnection()寻找可用连接。 123456789101112131415161718192021222324private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException &#123; while (true) &#123; RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); // If this is a brand new connection, we can skip the extensive health checks. synchronized (connectionPool) &#123; if (candidate.successCount == 0) &#123; return candidate; &#125; &#125; // Do a (potentially slow) check to confirm that the pooled connection is still good. If it // isn't, take it out of the pool and start again. if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123; noNewStreams(); continue; &#125; return candidate; &#125; &#125; 轮询的方式寻找，利用findConnection()寻找一个候选连接，先判断是否为一个全新的连接，若是，跳过检查，直接返回该连接；若不是，则检查该连接是否依然可用。 findConnection()的内部实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123; boolean foundPooledConnection = false; RealConnection result = null; Route selectedRoute = null; Connection releasedConnection; Socket toClose; synchronized (connectionPool) &#123; if (released) throw new IllegalStateException(\"released\"); if (codec != null) throw new IllegalStateException(\"codec != null\"); if (canceled) throw new IOException(\"Canceled\"); //尝试使用一个已分配的连接，但可能会限制我们创建新的流 releasedConnection = this.connection; toClose = releaseIfNoNewStreams(); if (this.connection != null) &#123; // We had an already-allocated connection and it's good. result = this.connection; releasedConnection = null; &#125; if (!reportedAcquired) &#123; // If the connection was never reported acquired, don't report it as released! releasedConnection = null; &#125; // 1. 试图从连接池中获取连接 if (result == null) &#123; Internal.instance.get(connectionPool, address, this, null); if (connection != null) &#123; foundPooledConnection = true; result = connection; &#125; else &#123; selectedRoute = route; &#125; &#125; &#125; closeQuietly(toClose); if (releasedConnection != null) &#123; eventListener.connectionReleased(call, releasedConnection); &#125; if (foundPooledConnection) &#123; eventListener.connectionAcquired(call, result); &#125; if (result != null) &#123; // 如果上面从已分配或连接池其中一个能找到可用连接，则返回 return result; &#125; ... ...//省略代码 //创建一个新的连接 result = new RealConnection(connectionPool, selectedRoute); // 引用计数 acquire(result, false); &#125; &#125; ... ...//省略部分代码 synchronized (connectionPool) &#123; reportedAcquired = true; // 放入连接池 Internal.instance.put(connectionPool, result); //如果另一个并发创建多路连接到相同的地址，则删除重复数据 if (result.isMultiplexed()) &#123; socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; &#125; &#125; closeQuietly(socket); eventListener.connectionAcquired(call, result); return result; &#125; 上面代码中有三个关键点， 1、Internal.instance.get() ： 从连接池中获取连接 2、acquire()： 引用计数，具体是对StreamAllocation的计数，通过aquire()与release()操作RealConnection中的List&lt;Reference&gt;列表。 3、Internal.instance.put()：将连接放入连接池中。1和3中都有Internal.instance，instance实际就是Internal的一个实例，在创建OkHttpClient时已对instance进行了初始化， 初始化Internal的instance1234567891011121314151617181920212223Internal.instance = new Internal() &#123; ... ...//省略了部分代码 @Override public RealConnection get(ConnectionPool pool, Address address, StreamAllocation streamAllocation, Route route) &#123; return pool.get(address, streamAllocation, route); &#125; //删除重复数据 @Override public Socket deduplicate( ConnectionPool pool, Address address, StreamAllocation streamAllocation) &#123; return pool.deduplicate(address, streamAllocation); &#125; @Override public void put(ConnectionPool pool, RealConnection connection) &#123; pool.put(connection); &#125; &#125;; &#125; 通过上面代码发现，从连接池获取可用连接和添加新的连接到连接池，实际调用的是ConnectionPool的get()和put()方法。 连接池管理ConnectionPool在分析get和put操作前，先看下ConnectionPool的一些关键属性 12345678910111213141516171819202122232425262728293031//线程池，核心线程数为0，最大线程数为最大整数，线程空闲存活时间60s，//SynchronousQueue 直接提交策略private static final Executor executor = new ThreadPoolExecutor(0, Integer.MAX_VALUE , 60L , TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(\"OkHttp ConnectionPool\", true)); //空闲连接的最大连接数 private final int maxIdleConnections; //保持连接的周期 private final long keepAliveDurationNs; //双端队列，存放具体的连接 private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); //用于记录连接失败的route final RouteDatabase routeDatabase = new RouteDatabase();//构造函数//从这里可以知道，空闲连接的最大连接数为5，保持连接的周期是5分钟public ConnectionPool() &#123; this(5, 5, TimeUnit.MINUTES); &#125; public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) &#123; this.maxIdleConnections = maxIdleConnections; this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration); // Put a floor on the keep alive duration, otherwise cleanup will spin loop. if (keepAliveDuration &lt;= 0) &#123; throw new IllegalArgumentException(\"keepAliveDuration &lt;= 0: \" + keepAliveDuration); &#125; &#125; 了解了ConnectionPool内部的一些关键属性后，首先看下ConnectionPool 的get()方法。 12345678910RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; assert (Thread.holdsLock(this)); for (RealConnection connection : connections) &#123; if (connection.isEligible(address, route)) &#123; streamAllocation.acquire(connection, true); return connection; &#125; &#125; return null; &#125; 在get()方法内部对存放具体连接的双端队列connections进行遍历，如果连接有效，则利用acquire()计数。 1234567891011121314151617181920212223//StreamAllocation # acquire()public void acquire(RealConnection connection, boolean reportedAcquired) &#123; assert (Thread.holdsLock(connectionPool)); if (this.connection != null) throw new IllegalStateException(); this.connection = connection; this.reportedAcquired = reportedAcquired; //添加到RealConnection的allocations列表 connection.allocations.add(new StreamAllocationReference(this, callStackTrace)); &#125;//StreamAllocation # release() private void release(RealConnection connection) &#123; for (int i = 0, size = connection.allocations.size(); i &lt; size; i++) &#123; Reference&lt;StreamAllocation&gt; reference = connection.allocations.get(i); if (reference.get() == this) &#123; //从RealConnection的allocations列表中移除 connection.allocations.remove(i); return; &#125; &#125; throw new IllegalStateException(); &#125; 接着看ConnectionPool 的put()方法。 12345678void put(RealConnection connection) &#123; assert (Thread.holdsLock(this)); if (!cleanupRunning) &#123; cleanupRunning = true; executor.execute(cleanupRunnable); &#125; connections.add(connection); &#125; 先判断是否需要清理运行中的连接，然后添加新的连接到连接池。接下来看看cleanupRunnable的实现。 123456789101112131415161718private final Runnable cleanupRunnable = new Runnable() &#123; @Override public void run() &#123; while (true) &#123; long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) &#123; try &#123; ConnectionPool.this.wait(waitMillis, (int) waitNanos); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125; &#125; &#125; &#125;; 在cleanupRunnable的run方法会不停的调用cleanup清理并返回下一次清理的时间间隔。然后进入wait，等待下一次的清理。那么cleanup()是怎么计算时间间隔的？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253long cleanup(long now) &#123; int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; // Find either a connection to evict, or the time that the next eviction is due. synchronized (this) &#123; //遍历连接 for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123; RealConnection connection = i.next(); //检查连接是否是空闲状态， //不是，则inUseConnectionCount + 1 //是 ，则idleConnectionCount + 1 if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123; inUseConnectionCount++; continue; &#125; idleConnectionCount++; // If the connection is ready to be evicted, we're done. long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) &#123; longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; &#125; &#125; //如果超过keepAliveDurationNs或maxIdleConnections， //从双端队列connections中移除 if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) &#123; connections.remove(longestIdleConnection); &#125; else if (idleConnectionCount &gt; 0) &#123; //如果空闲连接次数&gt;0,返回将要到期的时间 // A connection will be ready to evict soon. return keepAliveDurationNs - longestIdleDurationNs; &#125; else if (inUseConnectionCount &gt; 0) &#123; // 连接依然在使用中，返回保持连接的周期5分钟 return keepAliveDurationNs; &#125; else &#123; // No connections, idle or in use. cleanupRunning = false; return -1; &#125; &#125; closeQuietly(longestIdleConnection.socket()); // Cleanup again immediately. return 0; &#125; 从上面可以知道，cleanupRunnable的主要工作是负责连接池的清理和回收。 总结： OkHttp3连接池的复用主要是对双端队列Deque进行操作，通过对StreamAllocation的引用计数实现自动回收。","categories":[{"name":"OkHttp3","slug":"OkHttp3","permalink":"http://gillben.cn/categories/OkHttp3/"}],"tags":[{"name":"OkHttp3","slug":"OkHttp3","permalink":"http://gillben.cn/tags/OkHttp3/"},{"name":"开源框架","slug":"开源框架","permalink":"http://gillben.cn/tags/开源框架/"}]},{"title":"OkHttp3 源码解析执行流程","slug":"OkHttp3/OkHttp3-源码解析执行流程","date":"2018-05-22T14:26:06.000Z","updated":"2018-07-12T12:45:50.176Z","comments":true,"path":"2018/05/22/OkHttp3/OkHttp3-源码解析执行流程/","link":"","permalink":"http://gillben.cn/2018/05/22/OkHttp3/OkHttp3-源码解析执行流程/","excerpt":"OkHttp是一款网络请求框架，【OkHttp传送门】，为了在开发中使用的更加得心应手，必然的要去探究其源码，分析其中的工作原理，而且还能学习框架的设计思想。文章主要对OkHttp整体的工作流程进行分析，所以一些操作方法并没有涉及，读者可以通过传送门阅读文档自行实践。在分析之前，先看一张整体的流程图（本文内容会根据图的流程展开）：","text":"OkHttp是一款网络请求框架，【OkHttp传送门】，为了在开发中使用的更加得心应手，必然的要去探究其源码，分析其中的工作原理，而且还能学习框架的设计思想。文章主要对OkHttp整体的工作流程进行分析，所以一些操作方法并没有涉及，读者可以通过传送门阅读文档自行实践。在分析之前，先看一张整体的流程图（本文内容会根据图的流程展开）： OkHttp请求网络的简单示例12345678910111213141516171819202122232425private static final String URL_CONTENT = \"https://www.baidu.com/\"; public static void doOkHttp() &#123; OkHttpClient okHttpClient = new OkHttpClient.Builder() .retryOnConnectionFailure(true) //连接失败后进行重连 .build(); final Request request = new Request.Builder() .url(URL_CONTENT) .build(); //异步方式请求网络 okHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; //请求失败 &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; //请求成功,对response进行处理 &#125; &#125;); &#125; 上面的代码，首先创建一个okHttpClient对象，调用newCall()并且request作为参数传入，然后执行enqueue()，并且new一个Callback，请求结果的回调，这个过程是异步的。 12//execute()是同步的方式请求网络，会阻塞UI线程，所以一般情况都是通过异步的方式请求网络okHttpClient.newCall(request).execute(); OkHttpClient的build()过程。1234567891011121314151617181920212223242526public Builder() &#123; dispatcher = new Dispatcher(); //异步请求调度器 protocols = DEFAULT_PROTOCOLS;//请求协议集合，默认为http/1.1和Http/2 connectionSpecs = DEFAULT_CONNECTION_SPECS;//连接规格 eventListenerFactory = EventListener.factory(EventListener.NONE);//事件监听器 proxySelector = ProxySelector.getDefault();//代理选择器 cookieJar = CookieJar.NO_COOKIES;//http cookies 提供持久化策略 socketFactory = SocketFactory.getDefault(); //socket工厂类 hostnameVerifier = OkHostnameVerifier.INSTANCE;//对host基本接口的验证 certificatePinner = CertificatePinner.DEFAULT; //约束的信任证书 proxyAuthenticator = Authenticator.NONE;//代理身份认证 authenticator = Authenticator.NONE; connectionPool = new ConnectionPool();//连接复用池 dns = Dns.SYSTEM;//默认使用系统的dns followSslRedirects = true; //遵循SSL重定向 followRedirects = true;//普通重定向 retryOnConnectionFailure = true;//连接失败后进行重新连接 connectTimeout = 10_000;//连接超时时间 readTimeout = 10_000;//读取数据超时时间 writeTimeout = 10_000;//发送数据超时时间 pingInterval = 0;//时间间隔 &#125;public OkHttpClient build() &#123; return new OkHttpClient(this); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950OkHttpClient(Builder builder) &#123; this.dispatcher = builder.dispatcher; this.proxy = builder.proxy; this.protocols = builder.protocols; this.connectionSpecs = builder.connectionSpecs; this.interceptors = Util.immutableList(builder.interceptors);//自定义的拦截器 this.networkInterceptors = Util.immutableList(builder.networkInterceptors);//网络拦截器 this.eventListenerFactory = builder.eventListenerFactory; this.proxySelector = builder.proxySelector; this.cookieJar = builder.cookieJar; this.cache = builder.cache;//创建OkHttpClient对象时的自定义缓存 this.internalCache = builder.internalCache;//内部缓存 this.socketFactory = builder.socketFactory; boolean isTLS = false; for (ConnectionSpec spec : connectionSpecs) &#123; isTLS = isTLS || spec.isTls(); &#125; if (builder.sslSocketFactory != null || !isTLS) &#123; this.sslSocketFactory = builder.sslSocketFactory; this.certificateChainCleaner = builder.certificateChainCleaner; &#125; else &#123; X509TrustManager trustManager = systemDefaultTrustManager(); this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager); this.certificateChainCleaner = CertificateChainCleaner.get(trustManager); &#125; this.hostnameVerifier = builder.hostnameVerifier; this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner( certificateChainCleaner); this.proxyAuthenticator = builder.proxyAuthenticator; this.authenticator = builder.authenticator; this.connectionPool = builder.connectionPool; this.dns = builder.dns; this.followSslRedirects = builder.followSslRedirects; this.followRedirects = builder.followRedirects; this.retryOnConnectionFailure = builder.retryOnConnectionFailure; this.connectTimeout = builder.connectTimeout; this.readTimeout = builder.readTimeout; this.writeTimeout = builder.writeTimeout; this.pingInterval = builder.pingInterval; if (interceptors.contains(null)) &#123; throw new IllegalStateException(\"Null interceptor: \" + interceptors); &#125; if (networkInterceptors.contains(null)) &#123; throw new IllegalStateException(\"Null network interceptor: \" + networkInterceptors); &#125; &#125; 通过建造者模式创建OkHttpClient对象，并且配置各种参数。 Request的Builder()的过程1234567891011121314151617public Builder() &#123; this.method = \"GET\"; //请求方法，默认GET this.headers = new Headers.Builder();//创建请求头 &#125;public Request build() &#123; if (url == null) throw new IllegalStateException(\"url == null\"); return new Request(this); &#125;Request(Builder builder) &#123; this.url = builder.url; //请求url this.method = builder.method;//请求方法 this.headers = builder.headers.build();//请求头 this.body = builder.body;//请求体 this.tag = builder.tag != null ? builder.tag : this; &#125; Request也是以建造者模式创建对象，配置参数。关于HTTP报文结构图（左图对应Request，右图对应Response）： okHttpClient.newCall()1234567891011public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */); &#125;//RealCall # newRealCallstatic RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; &#125; 调用newCall()实际返回的是一个RealCall(继承自Call)对象。RealCall内部封装了网络请求和请求结果回调。那么，上面的异步请求实际调用的是RealCall的enqueue()方法。 RealCall # enqueue()12345678910111213public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; //若任务已经执行，则抛出IllegalStateException if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; //跟踪调用堆栈 captureCallStackTrace(); //监听开始事件 eventListener.callStart(this); // 1 client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 上面代码的核心是注释1处，client.dispatcher()返回一个Dispatcher对象，异步请求调度器，里面会对任务进行分辨，是立刻执行还是放入等待队列。AsyncCall继承NamedRunnable（实现了Runnable接口）类，接着进入Dispatcher的enqueue()方法： 12345678synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125; &#125; 从代码可以发现，Dispatcher的enqueue()是一个同步方法，maxRequests是最大请求数(值为64)，maxRequestsPerHost是Host最大请求数据(值为5)，当满足这两个条件时，把任务添加到执行队列runningAsyncCalls，立刻执行，否则加入等待队列readyAsyncCalls，等待异步调用。executorService()内部创建了一个执行任务的线程池，并且返回一个执行对象ExecutorService。executorService()的内部实现： 1234567public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(\"OkHttp Dispatcher\", false)); &#125; return executorService; &#125; 以单例模式中的懒汉模式创建了一个线程池。其实上面创建的线程池和我们直接用Executors的newCachedThreadPool()创建是类似的，核心线程数为0，线程空闲时的超时时间60s，直接提交策略。关于线程池的分析，可以阅读【探索Java 线程池】这篇文章。在这里，往线程池中添加的任务对象是AsyncCall，那么看看AsyncCall的内部实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super(\"OkHttp %s\", redactedUrl()); this.responseCallback = responseCallback; &#125; String host() &#123; return originalRequest.url().host(); &#125; Request request() &#123; return originalRequest; &#125; RealCall get() &#123; return RealCall.this; &#125; @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; //核心请求 Response response = getResponseWithInterceptorChain(); //根据是否取消RetryAndFollowUpInterceptor,分别回调onFailure或onResponse if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; //请求完毕，移除runningAsyncCalls中当前执行的Call。 //并且查找等待队列readyAsyncCalls是否存在任务，存在，则添加执行队列runningAsyncCalls，然后执行任务 //如果runningAsyncCalls不存在任务，且idleCallback不为null，则启动空闲状态Runnable client.dispatcher().finished(this); &#125; &#125; &#125; NamedRunnable实现了Runnable接口，在其run()方法内部调用了execute()方法，这里运用了设计模式中的模板模式，那么，这里就把任务交给了AsyncCall的execute()方法。通过代码的注释可以知道，把请求交由了getResponseWithInterceptorChain()方法，这个方法直译过来意思就是：用拦截器链获取响应报文。而方法内部也正运用了设计模式中的责任链模式。 模板模式优点：封装不变部分，扩展可变部分；提取公共部分代码，便于维护。缺点：在代码阅读方面可能会带来相对的难度。 责任链模式优点：对请求者和处理者关系解耦，提高了代码灵活性。缺点：如果处理者太多，过多的遍历会导致性能降低。 回到OkHttp的请求流程，上面已经把任务交由了getResponseWithInterceptorChain()方法，那么，看下其内部实现。 1234567891011121314151617181920Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); //初始化OkHttpClient对象时添加的自定义interceptors interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; //添加用户自定义的networkInterceptors interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); &#125; getResponseWithInterceptorChain()内部添加各种拦截器，利用RealInterceptorChain将已有的拦截器进行串联，然后proceed()开始遍历拦截器。 123456789101112131415public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; ... ....//省略部分代码 // Call the next interceptor in the chain. //遍历拦截器链，index代表责任链中拦截器的下标，初始值为0 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); ... ...//省略部分代码 return response; &#125; 分析各个拦截器的作用 RetryAndFollowUpInterceptor：在连接失败后进行重新连接，必要时进行重定向，如果调用被取消，可能会抛出IOException BridgeInterceptor：构建访问网络的桥梁，首先，将用户请求转换成网络请求，然后访问网络，最后将网络响应转换成用户响应。 CacheInterceptor：缓存拦截器，从缓存中获取服务器请求，或者把服务器响应写入缓存中。 ConnectInterceptor：打开一个连接，去连接目标服务器。 CallServerInterceptor：拦截器链中的最后一个链点，通过网络请求服务器。 链式执行流程： RetryAndFollowUpInterceptor # intercept()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); //用于分配一个到服务器特定的HttpStream，内部封装了ConnectionPool连接池，管理Http的连接 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; int followUpCount = 0; Response priorResponse = null; //开启轮询 while (true) &#123; //若已取消连接，释放资源 if (canceled) &#123; streamAllocation.release(); throw new IOException(\"Canceled\"); &#125; Response response; boolean releaseConnection = true; try &#123; //调用下一个拦截器 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123; throw e.getLastConnectException(); &#125; releaseConnection = false; continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. //检测前一个Response if (priorResponse != null) &#123; response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); &#125; Request followUp = followUpRequest(response, streamAllocation.route()); //followUp为null，表示不要重定向，释放资源并且返回response if (followUp == null) &#123; if (!forWebSocket) &#123; streamAllocation.release(); &#125; return response; &#125; //关闭response的body closeQuietly(response.body()); //最大重定向次数20 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount); &#125; //如果是不可重复的请求体，抛出异常 if (followUp.body() instanceof UnrepeatableRequestBody) &#123; streamAllocation.release(); throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code()); &#125; //检测地址是否相同，释放旧连接，重新创建一个新的连接 if (!sameConnection(response, followUp.url())) &#123; streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; &#125; else if (streamAllocation.codec() != null) &#123; throw new IllegalStateException(\"Closing the body of \" + response + \" didn't close its backing stream. Bad interceptor?\"); &#125; request = followUp; priorResponse = response; &#125; &#125; BridgeInterceptor # intercept()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public Response intercept(Chain chain) throws IOException &#123; Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); //将用户的Request构造成服务器的Request RequestBody body = userRequest.body(); if (body != null) &#123; //请求体存在，进行转换 MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(\"Content-Type\", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(\"Content-Length\", Long.toString(contentLength)); requestBuilder.removeHeader(\"Transfer-Encoding\"); &#125; else &#123; requestBuilder.header(\"Transfer-Encoding\", \"chunked\"); requestBuilder.removeHeader(\"Content-Length\"); &#125; &#125; if (userRequest.header(\"Host\") == null) &#123; requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false)); &#125; //保持连接 if (userRequest.header(\"Connection\") == null) &#123; requestBuilder.header(\"Connection\", \"Keep-Alive\"); &#125; //使用Gzip压缩 boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null &amp;&amp; userRequest.header(\"Range\") == null) &#123; transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); &#125; //设置cookies List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(\"Cookie\", cookieHeader(cookies)); &#125; if (userRequest.header(\"User-Agent\") == null) &#123; requestBuilder.header(\"User-Agent\", Version.userAgent()); &#125; //传入已构造好的服务器Request，调用下一个拦截器，获取服务器的networkResponse Response networkResponse = chain.proceed(requestBuilder.build()); //保存networkResponse的cookie HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); //后续则是把networkResponse构造成用户的response Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(\"Content-Encoding\") .removeAll(\"Content-Length\") .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(\"Content-Type\"); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125; CacheInterceptor # intercept()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public Response intercept(Chain chain) throws IOException &#123; Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; //获取当前时间 long now = System.currentTimeMillis(); //获取缓存策略 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; //从缓存中追踪Response if (cache != null) &#123; cache.trackResponse(strategy); &#125; //如果缓存不适用，则关闭 if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); &#125; // 如果网络被禁止，且缓存为空，则返回失败 if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(\"Unsatisfiable Request (only-if-cached)\") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // 不需要网络时，从缓存中获取 if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; //调用下一个拦截者，从网络获取Response networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // 关闭body，防止内存泄露 if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // 如果缓存中存在Response，同时检测networkResponse是否被修改 if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). //更新缓存中的数据至最新 cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; //构建response Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); //把之前未缓存的添加至缓存中 if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; ConnectInterceptor # intercept()1234567891011121314151617public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); //获取httpCodec 对象，HttpCodec的实现类有Http1Codec和Http2Codec //分别对应Http1.1和Http2 //HttpCodec主要是对Http请求和Http响应进行编解码 HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); //调用下一个拦截器 return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125; StreamAllocation的newStream()方法内部实现 1234567891011121314151617181920212223public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try &#123; //寻找一个可用连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); //根据具体的resultConnection 创建resultCodec对象 HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) &#123; codec = resultCodec; return resultCodec; &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125; &#125; CallServerInterceptor # intercept()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); //写入请求头 httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; //检测是否有body的请求方法 if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; //如果请求头是\"100-continue\"，等待服务器的响应 if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) &#123; httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); &#125; if (responseBuilder == null) &#123; // Write the request body if the \"Expect: 100-continue\" expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); //将请求体转换成sink，并封装在CountingSink 内部 CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); &#125; else if (!connection.isMultiplexed()) &#123; // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection // from being reused. Otherwise we're still obligated to transmit the request body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); &#125; &#125; httpCodec.finishRequest(); //从httpCodec中获取响应头 if (responseBuilder == null) &#123; realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false); &#125; //构建response Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); //如果服务器返回的状态码是100，再次尝试读取具体的response int code = response.code(); if (code == 100) &#123; // server sent a 100-continue even though we did not request one. // try again to read the actual response responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); &#125; realChain.eventListener() .responseHeadersEnd(realChain.call(), response); //如果是WebSocket，并且返回状态码为101，表示响应body为空 if (forWebSocket &amp;&amp; code == 101) &#123; response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; //读取body response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; //如果响应头部是\"close\"，关闭流 if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) &#123; streamAllocation.noNewStreams(); &#125; //协议异常 if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength()); &#125; return response; &#125; 到这里，OkHttp的执行流程就分析完毕了。 关于OkHttp3系列的其它文章： OkHttp3 源码解析 连接池的复用 OkHttp3源码解析内部缓存","categories":[{"name":"OkHttp3","slug":"OkHttp3","permalink":"http://gillben.cn/categories/OkHttp3/"}],"tags":[{"name":"OkHttp3","slug":"OkHttp3","permalink":"http://gillben.cn/tags/OkHttp3/"},{"name":"开源框架","slug":"开源框架","permalink":"http://gillben.cn/tags/开源框架/"}]},{"title":"OkHttp3 源码解析内部缓存","slug":"OkHttp3/OkHttp3源码解析内部缓存","date":"2018-05-22T14:26:06.000Z","updated":"2018-07-12T12:50:19.183Z","comments":true,"path":"2018/05/22/OkHttp3/OkHttp3源码解析内部缓存/","link":"","permalink":"http://gillben.cn/2018/05/22/OkHttp3/OkHttp3源码解析内部缓存/","excerpt":"OkHttp3系列文章 OkHttp3 源码解析执行流程 OkHttp3 源码解析 连接池的复用 如果有了解过OkHttp的执行流程，可以知道，在拦截器链中有一个缓存拦截器CacheInterceptor，里面决定了是由缓存中获取数据还是通过网络获取。笔者也以这个为入口，展开对OkHttp的缓存分析","text":"OkHttp3系列文章 OkHttp3 源码解析执行流程 OkHttp3 源码解析 连接池的复用 如果有了解过OkHttp的执行流程，可以知道，在拦截器链中有一个缓存拦截器CacheInterceptor，里面决定了是由缓存中获取数据还是通过网络获取。笔者也以这个为入口，展开对OkHttp的缓存分析 CacheInterceptor # intercept123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public Response intercept(Chain chain) throws IOException &#123; //判断是否设置cache Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; //如果cache 不为null，从strategy中追踪Response //主要是对networkRequest 或cacheResponse 进行计数 if (cache != null) &#123; cache.trackResponse(strategy); &#125; //如果缓存不适用，则关闭IO流 if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); &#125; // 如果网络被禁止并且无缓存，则返回失败504 if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(\"Unsatisfiable Request (only-if-cached)\") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // 在无网络时从缓存中获取 if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; //调用下一个拦截器，访问网络 networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // 如果缓存中已经存在对应的Response的处理 if (cacheResponse != null) &#123; //表示数据未做修改 if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); //主要是更新response头部数据 cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); //写入缓存 if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; //移除networkRequest if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; CacheStrategy内部封装了网络请求对象networkRequest和cacheResponse（实际就是开始获取的候选缓存对象cacheCandidate）。它是OkHttp的缓存策略的核心。关于缓存策略，笔者准备另写一篇文章进行分析，现在先不过多的介绍。 回到上面代码，首先判断是否已设置cache，如果已设置，根据chain.request()返回的request查找cache中对应的response，然后创建一个CacheStrategy对象strategy 。后续再通过对网络状态和缓存状态进行判断，如果是网络获取且未缓存，得到response后，会先更新写入缓存中，再返回。而上面代码的核心都是对cache的操作（get、put、update、remove）。 Cache的产生cache是InternalCache类型的对象，InternalCache是OkHttp的内部缓存接口。它又是怎么实现的呢？如果有了解过【OkHttp3 源码解析执行流程】这篇文章，会发现，在责任链开始执行之前就创建了CacheInterceptor对象，并从OkHttpClient获取了InternalCache的对象，在下面代码注释1处。 1234567891011121314151617181920Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); //1 interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); &#125; client.internalCache()的内部实现 123InternalCache internalCache() &#123; return cache != null ? cache.internalCache : internalCache; &#125; 代码比较简洁，根据cache是否为null，返回相应的internalCache。针对于cache == null 时返回的internalCache，这个是OkHttpClient静态代码块中创建Internal对象重写setCache()方法返回的。看下面代码(省略部分代码)： 123456789101112static &#123; Internal.instance = new Internal() &#123; ... ... @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) &#123; builder.setInternalCache(internalCache); &#125; ... ... &#125;; &#125; 经过查找发现，并没有任何地方调用setCache这个方法。也就是说在初始化OkHttpClient对象时，如果没有通过调用Cache()方法进行配置缓存，client.internalCache()将返回空，即无缓存。那么主要关注Cache()之后会发生什么。下面一个简单的调用Cache()配置缓存。 12345678910private void doOkHttp()&#123; //缓存路径 String path = Environment.getExternalStorageDirectory().getPath()+\"OkHttpCache\"; //最大缓存空间 long size = 1024*1024*50; OkHttpClient okHttpClient = new OkHttpClient.Builder() .cache(new Cache(new File(path),size)) //配置缓存 .build(); &#125; 这时在创建CacheInterceptor对象时调用client.internalCache()自然就返回了cache.internalCache。 Cache类的构造方法： 1234567public Cache(File directory, long maxSize) &#123; this(directory, maxSize, FileSystem.SYSTEM); &#125; Cache(File directory, long maxSize, FileSystem fileSystem) &#123; this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize); &#125; 在Cache类的构造方法中创建了DiskLruCache类型的cache 实例，这里的FileSystem.SYSTEM是FileSystem（文件系统接口）的实现，其内部是基于Okio的sink/source对缓存文件进行流操作。在DiskLruCache.Entry内部维护了两个数组，保存每个url请求对应文件的引用。然后通过DiskLruCache.Editor操作DiskLruCache.Entry中的数组，并为Cache.Entry提供Sink/source，对文件流进行操作。这点会在后续分析Cache的put和get中证实。 Cache的操作经过上面的分析，在配置了缓存的情况下，最终返回cache.internalCache，进入Cache类内部的internalCache。 12345678910111213141516171819202122232425262728293031final InternalCache internalCache = new InternalCache() &#123; @Override public Response get(Request request) throws IOException &#123; return Cache.this.get(request); &#125; @Override public CacheRequest put(Response response) throws IOException &#123; return Cache.this.put(response); &#125; @Override public void remove(Request request) throws IOException &#123; Cache.this.remove(request); &#125; @Override public void update(Response cached, Response network) &#123; Cache.this.update(cached, network); &#125; @Override public void trackConditionalCacheHit() &#123; Cache.this.trackConditionalCacheHit(); &#125; @Override public void trackResponse(CacheStrategy cacheStrategy) &#123; Cache.this.trackResponse(cacheStrategy); &#125; &#125;; 到这里，可以发现，经过internalCache最终回调了Cache本身的put、get、update等方法进行操作。这里主要分析下put和get中做了什么事。 Cache.put() 123456789101112131415161718192021222324252627282930313233343536373839404142CacheRequest put(Response response) &#123; //获取请求方法 String requestMethod = response.request().method(); if (HttpMethod.invalidatesCache(response.request().method())) &#123; try &#123; remove(response.request()); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; return null; &#125; //如果不是GET请求时返回的response，则不进行缓存 if (!requestMethod.equals(\"GET\")) &#123; return null; &#125; if (HttpHeaders.hasVaryAll(response)) &#123; return null; &#125; //把response封装在Cache.Entry中，调用DiskLruCache的edit()返回editor Entry entry = new Entry(response); DiskLruCache.Editor editor = null; try &#123; //把url进行 md5()，并转换成十六进制格式 //将转换后的key作为DiskLruCache内部LinkHashMap的键值 editor = cache.edit(key(response.request().url())); if (editor == null) &#123; return null; &#125; //用editor提供的Okio的sink对文件进行写入 entry.writeTo(editor); //利用CacheRequestImpl写入body return new CacheRequestImpl(editor); &#125; catch (IOException e) &#123; abortQuietly(editor); return null; &#125; &#125; 根据上面的代码发现，OkHttp只针对GET请求时返回的response进行缓存。官方解释：非GET请求下返回的response也可以进行缓存，但是这样做的复杂性高，且效益低。 在获取DiskLruCache.Editor对象editor后，调用writeTo()把url、请求方法、响应首部字段等写入缓存，然后返回一个CacheRequestImpl实例，在CacheInterceptor的intercept()方法内部调用cacheWritingResponse()写入body，最后调用CacheRequestImpl的close()完成提交（实际内部调用了Editor # commit() ）。首先进入DiskLruCache的edit()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public @Nullable Editor edit(String key) throws IOException &#123; return edit(key, ANY_SEQUENCE_NUMBER);&#125;synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123; //内部主要是利用FileSystem处理文件，如果这里出现了异常， //在最后会构建新的日志文件，如果文件已存在，则替换 initialize(); //检测缓存是否已关闭 checkNotClosed(); //检测是否为有效key validateKey(key); //lruEntries是LinkHashMap的实例，先查找lruEntries是否存在 Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) &#123; return null; // Snapshot is stale. &#125; //如果有Editor在操作entry，返回null if (entry != null &amp;&amp; entry.currentEditor != null) &#123; return null; &#125; //如果需要，进行clean操作 if (mostRecentTrimFailed || mostRecentRebuildFailed) &#123; executor.execute(cleanupRunnable); return null; &#125; // 把当前key在对应文件中标记DIRTY状态，表示正在修改， //清空日志缓冲区，防止泄露 journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\\n'); journalWriter.flush(); if (hasJournalErrors) &#123; return null; // 如果日志文件不能编辑 &#125; //为请求的url创建一个新的DiskLruCache.Entry实例 //并放入lruEntries中 if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; Editor editor = new Editor(entry); entry.currentEditor = editor; return editor;&#125; 在最后一步创建DiskLruCache.Entry实例entry ，这个entry本身是不存放任何数据的，主要是维护key（请求url）对应的文件列表，且内部currentEditor不为null，表示当前entry处于编辑状态。这一步返回editor后，前面已经了解到会调用Cache.Entry的writeTo()对返回的editor进行操作。 Cache.Entry # writeTo() 12345678910111213public void writeTo(DiskLruCache.Editor editor) throws IOException &#123; BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA)); sink.writeUtf8(url) .writeByte('\\n'); sink.writeUtf8(requestMethod) .writeByte('\\n'); sink.writeDecimalLong(varyHeaders.size()) .writeByte('\\n'); //... ...省略，都是利用sink进行写入操作 sink.close(); &#125; 在上面的代码，通过editor.newSink()为上层Cache.Entry提供了一个sink ，然后进行文件写入操作。这里只是把url、请求方法、首部字段等写入缓存，并未写入reponse的body内容。到这里，put()方法已经结束。那么，对于response的body的写入在哪里？前面也提到过，在CacheInterceptor的intercept()方法内部调用cacheWritingResponse()写入body。 12345678910111213@Override public Response intercept(Chain chain) throws IOException &#123; ... ... //省略代码 if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); //在内部实现了response的body的写入 return cacheWritingResponse(cacheRequest, response); &#125; ... ... //省略代码） Cache.get() 1234567891011121314151617181920212223242526272829303132333435@Nullable Response get(Request request) &#123; //把url转换成key String key = key(request.url()); DiskLruCache.Snapshot snapshot; Entry entry; try &#123; //通过DiskLruCache的get()根据具体的key获取DiskLruCache.Snapshot实例 snapshot = cache.get(key); if (snapshot == null) &#123; return null; &#125; &#125; catch (IOException e) &#123; // Give up because the cache cannot be read. return null; &#125; try &#123; //通过snapshot.getSource()获取一个Okio的Source entry = new Entry(snapshot.getSource(ENTRY_METADATA)); &#125; catch (IOException e) &#123; Util.closeQuietly(snapshot); return null; &#125; //根据snapshot获取缓存中的response Response response = entry.response(snapshot); if (!entry.matches(request, response)) &#123; Util.closeQuietly(response.body()); return null; &#125; return response;&#125; 相比于put过程，get过程相对简单点。DiskLruCache.Snapshot是DiskLruCache.Entry的一个快照值，内部封装了DiskLruCache.Entry对应文件的Source，简单的说：根据条件从DiskLruCache.Entry找到相应的缓存文件，并生成Source，封装在Snapshot内部，然后通过snapshot.getSource()获取Source，对缓存文件进行读取操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//DiskLruCache # get()public synchronized Snapshot get(String key) throws IOException &#123; initialize(); checkNotClosed(); validateKey(key); //从lruEntries查找entry， Entry entry = lruEntries.get(key); if (entry == null || !entry.readable) return null; //得到Entry的快照值snapshot Snapshot snapshot = entry.snapshot(); if (snapshot == null) return null; redundantOpCount++; journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\\n'); //如果redundantOpCount超过2000，且超过lruEntries的大小时，进行清理操作 if (journalRebuildRequired()) &#123; executor.execute(cleanupRunnable); &#125; return snapshot; &#125;//DiskLruCache.Entry # snapshot()Snapshot snapshot() &#123; if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError(); Source[] sources = new Source[valueCount]; // Defensive copy since these can be zeroed out. long[] lengths = this.lengths.clone(); try &#123; //遍历已缓存的文件，生成相应的sources for (int i = 0; i &lt; valueCount; i++) &#123; sources[i] = fileSystem.source(cleanFiles[i]); &#125; //创建Snapshot并返回 return new Snapshot(key, sequenceNumber, sources, lengths); &#125; catch (FileNotFoundException e) &#123; // A file must have been deleted manually! for (int i = 0; i &lt; valueCount; i++) &#123; if (sources[i] != null) &#123; Util.closeQuietly(sources[i]); &#125; else &#123; break; &#125; &#125; // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache // size.) try &#123; removeEntry(this); &#125; catch (IOException ignored) &#123; &#125; return null; &#125; &#125; Cache.Entry # response() 1234567891011121314151617181920public Response response(DiskLruCache.Snapshot snapshot) &#123; String contentType = responseHeaders.get(\"Content-Type\"); String contentLength = responseHeaders.get(\"Content-Length\"); Request cacheRequest = new Request.Builder() .url(url) .method(requestMethod, null) .headers(varyHeaders) .build(); return new Response.Builder() .request(cacheRequest) .protocol(protocol) .code(code) .message(message) .headers(responseHeaders) .body(new CacheResponseBody(snapshot, contentType, contentLength)) .handshake(handshake) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(receivedResponseMillis) .build(); &#125; 总结：经过分析OkHttp源码，可以知道：Cache只是一个上层的执行者，内部真正的缓存是由DiskLruCache实现的。在DiskLruCache里面通过FileSystem，基于Okio的Sink/Source对文件进行流操作。","categories":[{"name":"OkHttp3","slug":"OkHttp3","permalink":"http://gillben.cn/categories/OkHttp3/"}],"tags":[{"name":"OkHttp3","slug":"OkHttp3","permalink":"http://gillben.cn/tags/OkHttp3/"},{"name":"开源框架","slug":"开源框架","permalink":"http://gillben.cn/tags/开源框架/"}]},{"title":"View加载优化之懒汉模式-ViewStub","slug":"View加载优化之懒汉模式-ViewStub","date":"2018-05-20T00:54:45.603Z","updated":"2018-07-12T12:52:29.390Z","comments":true,"path":"2018/05/20/View加载优化之懒汉模式-ViewStub/","link":"","permalink":"http://gillben.cn/2018/05/20/View加载优化之懒汉模式-ViewStub/","excerpt":"谈到布局优化，通常都会想到标签include和merge。简单先说下这两个标签的好处：include可以减少布局文件内容，比如，在我们需要在多个布局中都添加标题栏时，可以创建一个单独的xml文件，添加标题内容到该xml中，然后在需要用到的目标布局里面用include标签添加已创建好的标题栏；merge可以减少多余的包含控件。两者一起使用，可以减少布局的层级结构，从而减少绘制的工作量。注意：include标签只支持android:layout_with和android:layout_height属性，其它属性是不支持的。O了~开始这章的重点， 很多时候，在初始化程序时都是一次性把布局加载进来，使得绘制工作量变多，导致程序初始化性能降低。比如：网络请求错误时的布局、一些评论显示的布局（未有评论前）等等，这些布局我们并不经常用到，能不能按需加载？可以，那就是ViewStub。","text":"谈到布局优化，通常都会想到标签include和merge。简单先说下这两个标签的好处：include可以减少布局文件内容，比如，在我们需要在多个布局中都添加标题栏时，可以创建一个单独的xml文件，添加标题内容到该xml中，然后在需要用到的目标布局里面用include标签添加已创建好的标题栏；merge可以减少多余的包含控件。两者一起使用，可以减少布局的层级结构，从而减少绘制的工作量。注意：include标签只支持android:layout_with和android:layout_height属性，其它属性是不支持的。O了~开始这章的重点， 很多时候，在初始化程序时都是一次性把布局加载进来，使得绘制工作量变多，导致程序初始化性能降低。比如：网络请求错误时的布局、一些评论显示的布局（未有评论前）等等，这些布局我们并不经常用到，能不能按需加载？可以，那就是ViewStub。 为什么用ViewStub能提升程序初始化性能ViewSub继承于View，本身是一个视图。但其有一个特点，就是轻量级的，宽和高都为0，并且它不参与绘制和任何的布局，为什么这么说，一起看下ViewStub源码。 123456789101112131415161718192021222324public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewStub, defStyleAttr, defStyleRes); mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID); mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0); mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID); a.recycle(); setVisibility(GONE); //在初始构造方法中就已经设置了GONE setWillNotDraw(true); &#125;... ...//省略部分代码 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(0, 0); //测量中设置宽和高为0 &#125; @Override public void draw(Canvas canvas) &#123; //无任何绘制 &#125; 根据上面的代码，我们可以知道，声明一个ViewStub时，只是起到了一个占位的作用，并没有实际的绘制和布局。 怎么去使用ViewStub，做到按需加载，一起看下下面一段简单描述。首先，主布局声明一个ViewStub： 1234567891011121314&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.rickybin.viewstubtest.MainActivity\"&gt; &lt;ViewStub android:id=\"@+id/textStub\" android:inflatedId=\"@+id/text_inflate_id\" //设置目标布局ID android:layout=\"@layout/text_layout\" //获取目标布局 android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/RelativeLayout&gt; text_layout的内容： 12345&lt;TextView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/textId\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"ViewStub的目标TextView\" /&gt; activity的代码： 1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; private ViewStub textStub; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; private void initView() &#123; textStub = (ViewStub) findViewById(R.id.textStub); if (mTextView != null)&#123; mTextView = (TextView) textStub.inflate(); //加载相应的TextView &#125; mTextView.setText(\"获取textview\"); &#125;&#125; 在activity代码initView()中判断mTextView是否为null，调用inflate()加载，这时就会把“@layout/text_layout”实例化出来。ViewStub还有一种方法加载布局，就是用setVisibility去加载，其实这个方法中最终还是调用了inflate()加载布局。再看看ViewStub源码中setVisibility的定义 123456789101112131415public void setVisibility(int visibility) &#123; if (mInflatedViewRef != null) &#123; //是否已加载目标布局 View view = mInflatedViewRef.get(); if (view != null) &#123; view.setVisibility(visibility); &#125; else &#123; throw new IllegalStateException(\"setVisibility called on un-referenced view\"); &#125; &#125; else &#123; //加载目标布局 super.setVisibility(visibility);//先由父类setVisibility再inflate if (visibility == VISIBLE || visibility == INVISIBLE) &#123; inflate(); &#125; &#125;&#125; 既然都是用inflate()加载，那我们一起看看在inflate里具体做了什么： 123456789101112131415161718192021222324252627282930313233343536373839public View inflate() &#123; final ViewParent viewParent = getParent(); //获取ViewStub所在的父视图 if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) &#123; if (mLayoutResource != 0) &#123; final ViewGroup parent = (ViewGroup) viewParent; final View view = inflateViewNoAdd(parent); replaceSelfWithView(view, parent); //替换ViewStub自身 //把View赋值给mInflatedViewRef mInflatedViewRef = new WeakReference&lt;&gt;(view); if (mInflateListener != null) &#123; mInflateListener.onInflate(this, view); &#125; return view; &#125; else &#123; throw new IllegalArgumentException(\"ViewStub must have a valid layoutResource\"); &#125; &#125; else &#123; throw new IllegalStateException(\"ViewStub must have a non-null ViewGroup viewParent\"); &#125; &#125;//获取LayoutInflater指定的布局，赋值给变量Viewprivate View inflateViewNoAdd(ViewGroup parent) &#123; final LayoutInflater factory; if (mInflater != null) &#123; factory = mInflater; &#125; else &#123; factory = LayoutInflater.from(mContext); &#125; final View view = factory.inflate(mLayoutResource, parent, false); if (mInflatedId != NO_ID) &#123; view.setId(mInflatedId); &#125; return view; &#125; replaceSelfWithView()方法 1234567891011121314private void replaceSelfWithView(View view, ViewGroup parent) &#123; final int index = parent.indexOfChild(this); //移除父布局中的ViewStub parent.removeViewInLayout(this); //这里是用ViewStub的android:with和android:height设置目标布局 final ViewGroup.LayoutParams layoutParams = getLayoutParams(); //添加目标布局到父布局中 if (layoutParams != null) &#123; parent.addView(view, index, layoutParams); &#125; else &#123; parent.addView(view, index); &#125; &#125; 从上面我们可以分析得到结果，ViewStub去加载目标布局时，其实是先把LayoutInflater指定的layout实例化后赋值给变量View，然后ViewStub自身会从父视图中移除，再把变量View添加进父视图中。也就是说ViewStub只能inflate一次，之后ViewStub对象就会置空，不再是整个布局结构中的一部分了。要注意一点，如果ViewStub设置了inflatedId，将会赋值给变量View的id。","categories":[{"name":"View系列","slug":"View系列","permalink":"http://gillben.cn/categories/View系列/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://gillben.cn/tags/Android/"},{"name":"源码","slug":"源码","permalink":"http://gillben.cn/tags/源码/"},{"name":"View","slug":"View","permalink":"http://gillben.cn/tags/View/"}]},{"title":"View的事件分发","slug":"Android-View的事件分发","date":"2018-05-20T00:28:16.000Z","updated":"2018-07-12T11:35:14.333Z","comments":true,"path":"2018/05/20/Android-View的事件分发/","link":"","permalink":"http://gillben.cn/2018/05/20/Android-View的事件分发/","excerpt":"View的事件分发所针对的是MotionEvent事件，在Touch过程中会产生大量的MotionEvent，记录了与Touch相关的事件。一次ACTION_DOWN、中间可能多次ACTION_MOVE、一次ACTION_UP，这便是一次完整的MotionEvent事件。在我们点击屏幕的那一刻，会先经过硬件的一系列处理，然后在当前应用的主(UI)线程中接收到来自底层传输过来的input事件，将事件交付于ViewRootImpl的enqueueInputEvent()方法，通过ViewRootImpl的内部类InputStage转换处理，最终交给View的dispatchTouchEvent()方法，事件分发的开始。一个应用程序的根视图(顶级View)是DecorView，也就是说，View的事件分发实际是由DecorView中的dispatchTouchEvent()方法开始。 在处理View的事件分发时，View和ViewGroup(继承自View)稍有差异。 View的相关处理方法：dispatchTouchEvent()、onTouchEvent() ViewGroup的相关处理方法：dispatchTouchEvent()、onInterceptTouchEvent()、onTouchEvent()","text":"View的事件分发所针对的是MotionEvent事件，在Touch过程中会产生大量的MotionEvent，记录了与Touch相关的事件。一次ACTION_DOWN、中间可能多次ACTION_MOVE、一次ACTION_UP，这便是一次完整的MotionEvent事件。在我们点击屏幕的那一刻，会先经过硬件的一系列处理，然后在当前应用的主(UI)线程中接收到来自底层传输过来的input事件，将事件交付于ViewRootImpl的enqueueInputEvent()方法，通过ViewRootImpl的内部类InputStage转换处理，最终交给View的dispatchTouchEvent()方法，事件分发的开始。一个应用程序的根视图(顶级View)是DecorView，也就是说，View的事件分发实际是由DecorView中的dispatchTouchEvent()方法开始。 在处理View的事件分发时，View和ViewGroup(继承自View)稍有差异。 View的相关处理方法：dispatchTouchEvent()、onTouchEvent() ViewGroup的相关处理方法：dispatchTouchEvent()、onInterceptTouchEvent()、onTouchEvent() 1、DecorView # dispatchTouchEvent()12345public boolean dispatchTouchEvent(MotionEvent ev) &#123; final Window.Callback cb = mWindow.getCallback(); return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev); &#125; 上面代码中，mWindow是一个PhoneWindow类型的变量，在Activity的attach()方法中对mWindow进行赋值【可以参考这篇文章 — Activity的启动过程】。且Activity实现了Window.Callback接口（实现Window.Callback的不只有Activity，比如Dialog，这里以Activity为例），也就是说：cb.dispatchTouchEvent()回调的是Activity中的dispatchTouchEvent()，执行这一步首先要满足前提条cb是否存在，PhoneWindow没有销毁，mFeatureId &lt; 0表示DecorView存在。否则会执行ViewGroup的dispatchTouchEvent()方法（DecorView继承FrameLayout）。 2、Activity # dispatchTouchEvent()123456789101112public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; //内部是一个空实现，用于点击时与用户交互 onUserInteraction(); &#125; //getWindow()返回PhoneWindow对象 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; //若前面没有消费事件，最后交给Activity的onTouchEvent return onTouchEvent(ev); &#125; 这里的实现很简洁，先交给PhoneWindow分发，如果没有消费事件，则在Activity的onTouchEvent()方法中消费。 3、PhoneWindow # superDispatchTouchEvent()1234public boolean superDispatchTouchEvent(MotionEvent event) &#123; //mDecor指的是DecorView return mDecor.superDispatchTouchEvent(event); &#125; 进入DecorView中的superDispatchTouchEvent() 123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; 前面已注明了DecorView是继承自FrameLayout（继承ViewGroup），那么这里也就自然而然的把分发任务交给了ViewGroup的dispatchTouchEvent()。 4、ViewGroup # dispatchTouchEvent()，由于代码量太长，这里选择关键性的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... ... // 如果是点击事件，先对之前的状态进行清除 //1、把mFirstTouchTarget(TouchTarget对象)链表清空，同时mFirstTouchTarget置空 //mFirstTouchTarget链表内部存放的是接受了触摸事件的view //2、重置FLAG_DISALLOW_INTERCEPT标识位(若设置了这个标识，表示禁止ViewGroup的拦截） //可以通过requestDisallowInterceptTouchEvent()进行设置， if (actionMasked == MotionEvent.ACTION_DOWN) &#123; cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // 检查是否进行拦截 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; // 检查是否已设置FLAG_DISALLOW_INTERCEPT标识 // 若设置，则不进行拦截，intercepted为false // 否则拦截，由onInterceptTouchEvent()决定intercepted的状态 // onInterceptTouchEvent()默认返回false final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; ... ... // 检查当前触摸事件是否被取消 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; //把当前ViewGrop的触摸事件进行分发给子View和子ViewGroup //在这之前需要满足两个条件：1、触摸事件没有取消 2、没有被拦截 //如果当前ViewGroup的子View接收到触摸事件，则把该子View添加到mFirstTouchTarget链表 final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; //记录触摸事件的序列号，事件Id，点击事件的Id总是为0， //在多指触控下，会产生多个Id,比如第一根手指，记录0，第二根手机记录1 ~ ~ ~ final int actionIndex = ev.getActionIndex(); final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // 清除早期的触摸目标 removePointersFromTouchTargets(idBitsToAssign); // 获取当前ViewGroup包含的子元素，进行遍历，然后对触摸事件进行分发 // 如果子元素也是ViewGroup，那么就对其里面的子元素遍历，如此递归下去 final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; //判断子View是否能接收触摸事件 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; // 先查找mFirstTouchTarget链表，是否存在该View // 若查找到，则返回当前View在链表中的节点赋值给newTouchTarget // 若没有，则返回null newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; //重置子View的mPrivateFlags中的PFLAG_CANCEL_NEXT_UP_EVENT resetCancelNextUpFlag(child); //将触摸事件分发给子View if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; //若子元素（包含子View和子ViewGroup）可以接收到触摸事件， // 通过addTouchTarget()把已接收触摸事件的子元素添加到 //mFirstTouchTarget链表，并把当前子元素作为头结点返回，赋值给newTouchTarget mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; //在newTouchTarget为null，mFirstTouchTarget不为null时， //把mFirstTouchTarget赋值给newTouchTarget，作为链表第一个节点 if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125;... ... // 进一步对触摸事件的分发进行处理，mFirstTouchTarget==null表示未有 // 子View接收到触摸事件，此时，会交由ViewGroup的父类View的dispatchTouchEvent()进行分发， //然后再交给onTouch()或onTouchEvent()进行处理 //onTouch()优先于onTouchEvent()，但是要setOnTouchListener()后才生效 // 如果mFirstTouchTarget != null，表示存在子View，则分发到子View if (mFirstTouchTarget == null) &#123; handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // 完成后重置触摸状态 if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if(!handled&amp;&amp;mInputEventConsistencyVerifier!=null)&#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev,1); &#125; return handled; &#125; 关于ViewGroup的事件分发，由于代码太长，所以直接在里面注释了，这样跟着代码会比较容易理解。上面阐述了关于ViewGroup的整个分发过程，在第二个省略号的下面一段代码，从其 if 条件可以知道，这段代码只有在ViewGroup发生ACTION_DOWN事件时才会执行(分发事件)，而后续的事件(ACTION_MOVE、ACTION_UP)将由第三个省略号下面一段代码中执行分发，这时会遍历mFirstTouchTarget链表，找到具体的子View进行分配事件。（实际就是：假设当前ViewGroup中包含三个子View，分别是A B C，如果ACTION_DOWN事件分发到了A，那么后续的事件一定不会分发到B或C）下面进一步去分析dispatchTransformedTouchEvent() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; //这里检测是否需要发送ACTION_CANCEL事件。 final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; //分发给当前ViewGroup handled = super.dispatchTouchEvent(event); &#125; else &#123; //分发给子View handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // 计算触摸事件Id final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; if (newPointerIdBits == 0) &#123; return false; &#125; final MotionEvent transformedEvent; //若触摸事件Id相同，不需要重新计算MotionEvent，直接进行分发 if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; //child为null，交由父类分发，否则交由child分发 if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // Perform any necessary transformations and dispatch. if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled; &#125; 在dispatchTransformedTouchEvent()中主要是对子View进行判断，如果子View为null，则分发交由super.dispatchTouchEvent()，也就是由View的dispatchTouchEvent()分发，然后交给onTouch()(如果设置了OnTouchListener)或onTouchEvent()，如果这时候onTouchEvent()依旧返回false，则交由当前ViewGroup的上一级去处理。 5、View # dispatchTouchEvent()，省略了部分代码1234567891011121314151617181920212223242526272829303132333435public boolean dispatchTouchEvent(MotionEvent event) &#123; ... ... final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // 接收到ACTION_DOWN，停止嵌套滑动 stopNestedScroll(); &#125; //判断View是否被屏蔽，是否能被点击， //然后再确定是否执行onTouch或onTouchEvent if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //在这里注意下li.mOnTouchListener.onTouch()，这里说明了 //onTouch会先于onTouchEvent执行，前提：当前View设置了OnTouchListener ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; //若没有设置OnTouchListener，交给onTouchEvent if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; ... ... return result; &#125; 关键的步骤已在代码中注释，就不再另外赘述了。接着看下View的onTouchEvent()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); //计算View是否可点击 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //这里View被禁用，调用了setEnabled(false)或android:enabled=false //返回其点击状态，View默认是不可点击的 //可以通过setClickable()或者android:clickable设置点击状态 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; return clickable; &#125; //委托事件给其它View，mTouchDelegate默认为null if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; //判断View的点击状态，设置焦点。后续执行onClick()、onLongClick() if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; handleTooltipUp(); &#125; if (!clickable) &#123; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; &#125; boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123; mPrivateFlags3 |= PFLAG3_FINGER_DOWN; &#125; mHasPerformedLongPress = false; if (!clickable) &#123; checkForLongClick(0, x, y); break; &#125; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: if (clickable) &#123; setPressed(false); &#125; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) &#123; drawableHotspotChanged(x, y); &#125; // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button // Remove any future long press/tap checks removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; &#125; break; &#125; return true; &#125; return false; &#125; 关于View的事件分发大概流程到这里就结束了。Activity &gt; ViewGroup(可包含多个ViewGroup) &gt; View 。最后通过一张图的形式整理下上面的思路：","categories":[{"name":"View系列","slug":"View系列","permalink":"http://gillben.cn/categories/View系列/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://gillben.cn/tags/Android/"},{"name":"源码","slug":"源码","permalink":"http://gillben.cn/tags/源码/"},{"name":"View","slug":"View","permalink":"http://gillben.cn/tags/View/"}]},{"title":"Java线程池","slug":"探索Java-线程池","date":"2018-05-20T00:28:16.000Z","updated":"2018-07-12T12:40:25.851Z","comments":true,"path":"2018/05/20/探索Java-线程池/","link":"","permalink":"http://gillben.cn/2018/05/20/探索Java-线程池/","excerpt":"多线程可以说是开发应用程序的标配了，在Java中通常情况都是通过new Thread()来创建一个工作线程，如果需要并发执行任务时，以这种方式创建线程，由于线程的频繁创建和销毁，会消耗大量的系统资源，程序出现卡顿，甚至出现OOM。因此，Java中利用了线程池，它通过对已存在线程的重用，降低了线程创建和销毁所造成的资源消耗，可以自己控制并发数，不必等待新线程的创建时间便执行任务，提高了系统的响应速度。 Java通过Executors这个类，提供了四种线程池： newFixedThreadPool() newSingleThreadExecutor() newCachedThreadPool() newScheduledThreadPool()","text":"多线程可以说是开发应用程序的标配了，在Java中通常情况都是通过new Thread()来创建一个工作线程，如果需要并发执行任务时，以这种方式创建线程，由于线程的频繁创建和销毁，会消耗大量的系统资源，程序出现卡顿，甚至出现OOM。因此，Java中利用了线程池，它通过对已存在线程的重用，降低了线程创建和销毁所造成的资源消耗，可以自己控制并发数，不必等待新线程的创建时间便执行任务，提高了系统的响应速度。 Java通过Executors这个类，提供了四种线程池： newFixedThreadPool() newSingleThreadExecutor() newCachedThreadPool() newScheduledThreadPool() 下面分别会为这四种不同方式创建的线程池进行分析，在此之前，先看一段ThreadPoolExecutor的构造方法源码： 1234567ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ThreadPoolExecutor是Java线程池中的核心类，上面四种创建线程池的方式也是通过ThreadPoolExecutor类完成的，并且以静态工厂方法模式封装在了Executors这个类中。这个构造函数是包含参数最多的，都是ThreadPoolExecutor类的关键属性。看下面分析： corePoolSize：核心线程数，必须大于或等于0 maximumPoolSize：线程池的最大线程数，必须大于1 keepAliveTime：线程在空闲时候的存活时间，必须大于或等于0 TimeUnit：存活的时间单位 workQueue：线程池中的任务队列，不能为空 threadFactory：线程工厂，不能为空 handler：线程饱和策略，不能为空 注意：在创建线程池时，后面的条件限制必须满足，否则异常。对于参数少的构造方法，threadFactory和handler会使用默认。 对于这几个属性简单了解后，接着分析之前提到的四种线程池1、newFixedThreadPool()123456789101112131415161718192021222324private void fixPool()&#123; ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 5; i++) &#123; int finalI = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\" --- \"+ finalI); &#125; &#125;); &#125; &#125;//...1 Executors类newFixedThreadPool()源码public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 输出： 12345pool-1-thread-2 --- 1pool-1-thread-1 --- 0pool-1-thread-3 --- 2pool-1-thread-1 --- 4pool-1-thread-2 --- 3 在上面代码注释1处可以知道，用newFixedThreadPool()创建的线程池，其核心线程数和最大线程数是相同的，且无超时限制(线程空闲是不会被终止(回收))。采用了LinkedBlockingQueue无界队列。根据输出结果分析：当添加前三个任务时，若无空闲线程的情况下会创建一个新的线程去执行任务。当达到创建线程池时设定的核心线程数后，后续的任务会被放进无界队列LinkedBlockingQueue中，等待前面的线程执行完成后才进行提交。 2、newSingleThreadExecutor()12345678910111213141516171819202122232425private void singlePool()&#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 3; i++) &#123; final int finalI = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\" \"+ finalI); &#125; &#125;); &#125; &#125;// Executors类newSingleThreadExecutor()源码public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 输出： 12345pool-1-thread-1 0pool-1-thread-1 1pool-1-thread-1 2pool-1-thread-1 3pool-1-thread-1 4 newSingleThreadExecutor()创建一个单线程的线程池，根据输出结果分析：串行的执行任务，若线程处于工作状态，任务会被放进无界队列LinkedBlockingQueue中，等待前面任务执行完成才会提交。 3、newCachedThreadPool()123456789101112131415161718192021222324private void cachePool()&#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; final int finalI = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\" --- \"+ finalI); &#125; &#125;); &#125; &#125;// Executors类newCachedThreadPool()源码public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 输出： 12345pool-1-thread-1 --- 0pool-1-thread-3 --- 2pool-1-thread-2 --- 1pool-1-thread-5 --- 4pool-1-thread-4 --- 3 newCachedThreadPool()创建的线程池，核心线程数是0；最大线程数是最大常数。设定了线程空闲时的存活时间为60s；SynchronousQueue队列不会存放任务，任务到来时就会被提交，执行。从输出结果可以发现：我们提交了5个任务，直接创建了5个线程进行执行。但是，在提交新任务时，如果有存在空闲的线程，则会重用这个空闲线程。我们改下上面代码，再看下输出结果。 1234567891011121314151617181920212223private void cachePool()&#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; final int finalI = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\" --- \"+ finalI); &#125; &#125;); //每隔一秒提交一次 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 输出： 12345pool-1-thread-1 --- 0pool-1-thread-2 --- 1pool-1-thread-1 --- 2pool-1-thread-2 --- 3pool-1-thread-1 --- 4 4、newScheduledThreadPool()123456789101112131415161718192021 private void scheduledPool()&#123; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3); executorService.schedule(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"延时执行\"); &#125; &#125;,2, TimeUnit.SECONDS); &#125;// Executors类newScheduledThreadPool()源码public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125;//ScheduledExecutorService的构造方法 public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125; newScheduledThreadPool()创建的线程池，核心线程数自定义，最大线程数为最大常数。空闲时的存活时间默认DEFAULT_KEEPALIVE_MILLIS = 10ms，DelayedWorkQueue延时队列。上面的代码创建的是延时执行一次任务。还可利用scheduleAtFixedRate创建一个定时循环执行任务。 1234567ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3); executorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"定时循环执行\"); &#125; &#125;,10,3000, TimeUnit.MILLISECONDS); 上面代码，创建了一个定时循环执行任务的线程池。初始执行延迟10ms，后续每一次任务相隔3000ms。scheduleAtFixedRate和scheduleWithFixedDelay类似，其中的区别：scheduleAtFixedRate的相隔时间是上个线程执行开始到下个线程执行开始的时间。scheduleWithFixedDelay的相隔时间是上个线程执行结束到下个线程执行开始的时间。 除了上面四种方式创建线程池，我们也可以通过ThreadPoolExecutor类自定义创建线程池，下面看一段AsyncTask中的源码(自定义线程池) 1234567891011121314151617181920212223private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE_SECONDS = 30; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); //允许核心线程超时终止 threadPoolExecutor.allowCoreThreadTimeOut(true);//sPoolWorkQueueprivate static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);//sThreadFactoryprivate static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); &#125; &#125;; 线程池的关闭：利用shutdown()或shutdownNow()关闭线程池 shutdown()：把线程池的状态设置为SHUTDOWN状态，中断所有没有正在执行任务的线程池。 shutdownNow()：把线程池的状态设置为STOP状态，中断所有的线程，包括正在执行任务的线程。 前面对线程池几个属性和创建方式进行了简单的阐述，下面再对几个属性进行详解： corePoolSize（核心线程数）：若线程池中的线程数小于corePoolSize，这时提交任务会创建新的线程执行。若大于或等于corePoolSize，提交任务时会根据是否存在空闲线程，决定是否创建新的线程来执行任务。也可以通过prestartCoreThread()或prestartAllCoreThreads()提前启动核心线程。 maximumPoolSize（最大线程数）：线程池中允许的最大线程数量，如果线程池的队列已满，且线程数小于maximumPoolSize，会创建新的线程执行任务，否则会被拒绝（RejectedExecutionException） keepAliveTime（线程空闲存活时间）：这个超时限制是对超过corePoolSize的线程的控制，如果核心线程也要实现这个机制，可以利用allowCoreThreadTimeOut(true)进行设置 TimeUnit（单位时间）：NANOSECONDS（纳秒），MICROSECONDS（微妙），MILLISECONDS（毫秒），SECONDS（秒），MINUTES（分），HOURS（小时），DAYS（天）； BlockingQueue（任务队列）：存放等待执行任务的阻塞队列。在线程数小于corePoolSize时，会创建新线程执行任务，不会进行排队。大于corePoolSize时，任务会添加到队列。若队列已满，且线程数不超过maximumPoolSize，则会创建新线程执行任务。否则会被拒绝。 ThreadFactory（线程工厂）：用于创建新的线程，设置线程优先级。 RejectedExecutionHandler（线程饱和策略）：ThreadPoolExecutor.AbortPolicy：处理程序遭到拒绝，则直接抛出运行时异常 RejectedExecutionException。(默认策略)ThreadPoolExecutor.CallerRunsPolicy：由调用线程执行该任务。策略实现了一种调节机制，不会抛弃任务，也不会抛出异常。ThreadPoolExecutor.DiscardPolicy：无法执行的任务将被删除。ThreadPoolExecutor.DiscardOldestPolicy：会先丢弃保存时间最长的任务(队列列头开始)，然后尝试添加新任务（失败后会重复前面的步骤） 常见的工作队列(BlockingQueue)： ArrayBlockingQueue ：基于数组的有界阻塞队列，当队列已满后添加会遭到拒绝。 LinkedBlockingQueue：基于链表的无界阻塞队列（默认），但可以通过构造函数去实现有固定长度的队列。 SynchronousQueue：一种直接提交策略，特性：添加一次任务，必须等待线程取走这次任务后才能添加其它任务。 PriorityBlockingQueue：优先级阻塞队列，插入元素时会按照定义的排序规则来对元素数组进行排序，入队的元素必须实现Comparable接口，执行时优先级高的会先被取出。","categories":[{"name":"Java","slug":"Java","permalink":"http://gillben.cn/categories/Java/"}],"tags":[{"name":"ThreadPool","slug":"ThreadPool","permalink":"http://gillben.cn/tags/ThreadPool/"},{"name":"Java线程","slug":"Java线程","permalink":"http://gillben.cn/tags/Java线程/"}]}]}